{"version":3,"sources":["webpack:///../node_modules/@polymer/iron-overlay-behavior/iron-focusables-helper.js","webpack:///../node_modules/@polymer/iron-fit-behavior/iron-fit-behavior.js","webpack:///../node_modules/@polymer/iron-overlay-behavior/iron-overlay-backdrop.js","webpack:///../node_modules/@polymer/iron-overlay-behavior/iron-overlay-manager.js","webpack:///../node_modules/@polymer/iron-overlay-behavior/iron-scroll-manager.js","webpack:///../node_modules/@polymer/iron-overlay-behavior/iron-overlay-behavior.js","webpack:///../node_modules/@polymer/neon-animation/neon-animatable-behavior.js","webpack:///../node_modules/@polymer/neon-animation/neon-animation-runner-behavior.js"],"names":["__webpack_require__","d","__webpack_exports__","IronFocusablesHelper","_polymer_polymer_lib_legacy_polymer_dom_js__WEBPACK_IMPORTED_MODULE_1__","p","Element","prototype","matches","matchesSelector","mozMatchesSelector","msMatchesSelector","oMatchesSelector","webkitMatchesSelector","getTabbableNodes","node","result","this","_collectTabbableNodes","_sortByTabIndex","isFocusable","element","call","isTabbable","_isVisible","_normalizedTabIndex","tabIndex","getAttribute","Number","nodeType","Node","ELEMENT_NODE","children","needsSort","push","localName","dom","getDistributedNodes","root","i","length","style","visibility","display","window","getComputedStyle","tabbables","len","pivot","Math","ceil","left","slice","right","_mergeSortByTabIndex","_hasLowerTabOrder","shift","concat","a","b","ati","max","bti","IronFitBehavior","properties","sizingTarget","type","Object","value","fitInto","noOverlap","Boolean","positionTarget","horizontalAlign","String","verticalAlign","dynamicAlign","horizontalOffset","notify","verticalOffset","autoFitOnAttach","_fitInfo","_fitWidth","innerWidth","getBoundingClientRect","width","_fitHeight","innerHeight","height","_fitLeft","_fitTop","top","_defaultPositionTarget","parent","parentNode","DOCUMENT_FRAGMENT_NODE","host","_localeHorizontalAlign","_isRTL","__shouldPosition","attached","direction","setTimeout","fit","bind","ShadyDOM","flush","detached","__deferredFit","clearTimeout","position","constrain","center","_discoverInfo","target","sizer","inlineStyle","sizerInlineStyle","maxWidth","maxHeight","boxSizing","positionedBy","vertically","bottom","horizontally","sizedBy","minWidth","parseInt","minHeight","margin","marginTop","marginRight","marginBottom","marginLeft","resetFit","info","property","refit","scrollLeft","scrollTop","rect","positionRect","__getNormalizedRect","fitRect","size","__getPosition","min","__sizeDimension","_sizeDimension","start","end","extent","flip","offset","offsetExtent","sizingOffset","document","documentElement","__getOffscreenArea","verticalCrop","horizontalCrop","abs","hAlign","vAlign","sizeNoMargins","positions","l","copy","key","candidate","vAlignOk","hAlignOk","alignOk","offscreenArea","diff","Polymer","_template","html","_templateObject","is","opened","reflectToAttribute","observer","listeners","transitionend","created","__openedRaf","_openedChanged","prepare","body","appendChild","open","close","complete","removeChild","_onTransitionend","event","cs","transitionDuration","opacity","isAttached","cancelAnimationFrame","requestAnimationFrame","toggleClass","IronOverlayManagerClass","_overlays","_minimumZ","_backdropElement","gestures","addEventListener","_onCaptureClick","_onCaptureFocus","_onCaptureKeyDown","constructor","backdropElement","createElement","deepActiveElement","active","activeElement","_bringOverlayAtIndexToFront","overlay","lastI","currentOverlay","_shouldBeBehindOverlay","minimumZ","currentOverlayZ","_getZ","_applyOverlayZ","addOrRemoveOverlay","addOverlay","removeOverlay","indexOf","trackBackdrop","insertionIndex","newZ","previousOverlay","splice","ensureMinimumZ","focusOverlay","current","_applyFocus","_overlayWithBackdrop","zIndex","getBackdrops","backdrops","withBackdrop","backdropZ","z","z1","_setZ","aboveZ","_overlayInPath","path","_manager","allowClickThrough","IronA11yKeysBehavior","keyboardEventMatchesKeys","_onCaptureEsc","_onCaptureTab","overlay1","overlay2","alwaysOnTop","_boundScrollHandler","currentLockingElement","IronOverlayManager","lastTouchPosition","pageX","pageY","lastRootTarget","lastScrollableNodes","scrollEvents","pushScrollLock","_lockingElements","cancelable","rootTarget","nodes","scrollables","lockingIndex","overflow","_getScrollableNodes","deltaX","deltaY","wheelDeltaX","wheelDeltaY","wheelDelta","axis","detail","targetTouches","touch","_getScrollInfo","verticalScroll","scrollHeight","clientHeight","scrollWidth","clientWidth","_getScrollingNode","_shouldPreventScrolling","preventDefault","undefined","capture","passive","_lockScrollInteractions","removeScrollLock","index","removeEventListener","_unlockScrollInteractions","IronOverlayBehaviorImpl","IronOverlayBehavior","canceled","readOnly","noAutoFocus","noCancelOnEscKey","noCancelOnOutsideClick","closingReason","restoreFocusOnClose","scrollAction","_focusedChild","iron-resize","observers","_focusNode","querySelector","_focusableNodes","ready","__isAnimating","__shouldRemoveTabIndex","__firstFocusableNode","__lastFocusableNode","__rafs","__restoreFocusNode","__scrollTop","__scrollLeft","__onCaptureScroll","__rootNodes","_ensureSetup","_observer","observeNodes","_onNodesChange","cb","unobserveNodes","_finishRenderOpened","_finishRenderClosed","toggle","_setCanceled","cancel","fire","defaultPrevented","invalidateTabbables","_overlaySetup","outline","removeAttribute","setAttribute","__deraf","__openedChanged","_canceledChanged","_withBackdropChanged","hasAttribute","_prepareRenderOpened","_preparePositioning","_finishPositioning","blur","focus","_renderOpened","_renderClosed","notifyResize","transition","webkitTransition","transform","webkitTransform","deepContains","stopPropagation","__ensureFirstLastFocusables","shiftKey","nodeToCheck","nodeToSet","shouldWrap","focusedNode","_onIronResize","focusableNodes","jobname","callback","rafs","__updateScrollObservers","__isValidScrollAction","__saveScrollPosition","__addScrollListeners","__removeScrollListeners","useShadow","assignedSlot","forEach","el","__restoreScrollPosition","scrollingElement","IronResizableBehavior","NeonAnimatableBehavior","animationConfig","entryAnimation","exitAnimation","_entryAnimationChanged","name","_exitAnimationChanged","_copyProperties","config1","config2","_cloneConfig","config","clone","isClone","_getAnimationConfigRecursive","map","allConfigs","thisConfig","_warn","_logf","Array","isArray","animatable","id","cachedConfig","getAnimationConfig","NeonAnimationRunnerBehavior","_configureAnimations","configs","results","resultsToPlay","neonAnimation","isNeonAnimation","configure","console","warn","timeline","play","e","animation","_shouldComplete","activeEntries","finished","playState","_complete","playAnimation","cookie","_active","onfinish","bubbles","cancelAnimation","k","entries","j"],"mappings":"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","file":"chunk.7f411ffa9df152cb8f05.js","sourcesContent":["/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\nimport '@polymer/polymer/polymer-legacy.js';\n\nimport {dom} from '@polymer/polymer/lib/legacy/polymer.dom.js';\n\nvar p = Element.prototype;\nvar matches = p.matches || p.matchesSelector || p.mozMatchesSelector ||\n    p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;\n\nexport const IronFocusablesHelper = {\n\n  /**\n   * Returns a sorted array of tabbable nodes, including the root node.\n   * It searches the tabbable nodes in the light and shadow dom of the chidren,\n   * sorting the result by tabindex.\n   * @param {!Node} node\n   * @return {!Array<!HTMLElement>}\n   */\n  getTabbableNodes: function(node) {\n    var result = [];\n    // If there is at least one element with tabindex > 0, we need to sort\n    // the final array by tabindex.\n    var needsSortByTabIndex = this._collectTabbableNodes(node, result);\n    if (needsSortByTabIndex) {\n      return this._sortByTabIndex(result);\n    }\n    return result;\n  },\n\n  /**\n   * Returns if a element is focusable.\n   * @param {!HTMLElement} element\n   * @return {boolean}\n   */\n  isFocusable: function(element) {\n    // From http://stackoverflow.com/a/1600194/4228703:\n    // There isn't a definite list, it's up to the browser. The only\n    // standard we have is DOM Level 2 HTML\n    // https://www.w3.org/TR/DOM-Level-2-HTML/html.html, according to which the\n    // only elements that have a focus() method are HTMLInputElement,\n    // HTMLSelectElement, HTMLTextAreaElement and HTMLAnchorElement. This\n    // notably omits HTMLButtonElement and HTMLAreaElement. Referring to these\n    // tests with tabbables in different browsers\n    // http://allyjs.io/data-tables/focusable.html\n\n    // Elements that cannot be focused if they have [disabled] attribute.\n    if (matches.call(element, 'input, select, textarea, button, object')) {\n      return matches.call(element, ':not([disabled])');\n    }\n    // Elements that can be focused even if they have [disabled] attribute.\n    return matches.call(\n        element, 'a[href], area[href], iframe, [tabindex], [contentEditable]');\n  },\n\n  /**\n   * Returns if a element is tabbable. To be tabbable, a element must be\n   * focusable, visible, and with a tabindex !== -1.\n   * @param {!HTMLElement} element\n   * @return {boolean}\n   */\n  isTabbable: function(element) {\n    return this.isFocusable(element) &&\n        matches.call(element, ':not([tabindex=\"-1\"])') &&\n        this._isVisible(element);\n  },\n\n  /**\n   * Returns the normalized element tabindex. If not focusable, returns -1.\n   * It checks for the attribute \"tabindex\" instead of the element property\n   * `tabIndex` since browsers assign different values to it.\n   * e.g. in Firefox `<div contenteditable>` has `tabIndex = -1`\n   * @param {!HTMLElement} element\n   * @return {!number}\n   * @private\n   */\n  _normalizedTabIndex: function(element) {\n    if (this.isFocusable(element)) {\n      var tabIndex = element.getAttribute('tabindex') || 0;\n      return Number(tabIndex);\n    }\n    return -1;\n  },\n\n  /**\n   * Searches for nodes that are tabbable and adds them to the `result` array.\n   * Returns if the `result` array needs to be sorted by tabindex.\n   * @param {!Node} node The starting point for the search; added to `result`\n   * if tabbable.\n   * @param {!Array<!HTMLElement>} result\n   * @return {boolean}\n   * @private\n   */\n  _collectTabbableNodes: function(node, result) {\n    // If not an element or not visible, no need to explore children.\n    if (node.nodeType !== Node.ELEMENT_NODE || !this._isVisible(node)) {\n      return false;\n    }\n    var element = /** @type {!HTMLElement} */ (node);\n    var tabIndex = this._normalizedTabIndex(element);\n    var needsSort = tabIndex > 0;\n    if (tabIndex >= 0) {\n      result.push(element);\n    }\n\n    // In ShadowDOM v1, tab order is affected by the order of distrubution.\n    // E.g. getTabbableNodes(#root) in ShadowDOM v1 should return [#A, #B];\n    // in ShadowDOM v0 tab order is not affected by the distrubution order,\n    // in fact getTabbableNodes(#root) returns [#B, #A].\n    //  <div id=\"root\">\n    //   <!-- shadow -->\n    //     <slot name=\"a\">\n    //     <slot name=\"b\">\n    //   <!-- /shadow -->\n    //   <input id=\"A\" slot=\"a\">\n    //   <input id=\"B\" slot=\"b\" tabindex=\"1\">\n    //  </div>\n    // TODO(valdrin) support ShadowDOM v1 when upgrading to Polymer v2.0.\n    var children;\n    if (element.localName === 'content' || element.localName === 'slot') {\n      children = dom(element).getDistributedNodes();\n    } else {\n      // Use shadow root if possible, will check for distributed nodes.\n      children = dom(element.root || element).children;\n    }\n    for (var i = 0; i < children.length; i++) {\n      // Ensure method is always invoked to collect tabbable children.\n      needsSort = this._collectTabbableNodes(children[i], result) || needsSort;\n    }\n    return needsSort;\n  },\n\n  /**\n   * Returns false if the element has `visibility: hidden` or `display: none`\n   * @param {!HTMLElement} element\n   * @return {boolean}\n   * @private\n   */\n  _isVisible: function(element) {\n    // Check inline style first to save a re-flow. If looks good, check also\n    // computed style.\n    var style = element.style;\n    if (style.visibility !== 'hidden' && style.display !== 'none') {\n      style = window.getComputedStyle(element);\n      return (style.visibility !== 'hidden' && style.display !== 'none');\n    }\n    return false;\n  },\n\n  /**\n   * Sorts an array of tabbable elements by tabindex. Returns a new array.\n   * @param {!Array<!HTMLElement>} tabbables\n   * @return {!Array<!HTMLElement>}\n   * @private\n   */\n  _sortByTabIndex: function(tabbables) {\n    // Implement a merge sort as Array.prototype.sort does a non-stable sort\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\n    var len = tabbables.length;\n    if (len < 2) {\n      return tabbables;\n    }\n    var pivot = Math.ceil(len / 2);\n    var left = this._sortByTabIndex(tabbables.slice(0, pivot));\n    var right = this._sortByTabIndex(tabbables.slice(pivot));\n    return this._mergeSortByTabIndex(left, right);\n  },\n\n  /**\n   * Merge sort iterator, merges the two arrays into one, sorted by tab index.\n   * @param {!Array<!HTMLElement>} left\n   * @param {!Array<!HTMLElement>} right\n   * @return {!Array<!HTMLElement>}\n   * @private\n   */\n  _mergeSortByTabIndex: function(left, right) {\n    var result = [];\n    while ((left.length > 0) && (right.length > 0)) {\n      if (this._hasLowerTabOrder(left[0], right[0])) {\n        result.push(right.shift());\n      } else {\n        result.push(left.shift());\n      }\n    }\n\n    return result.concat(left, right);\n  },\n\n  /**\n   * Returns if element `a` has lower tab order compared to element `b`\n   * (both elements are assumed to be focusable and tabbable).\n   * Elements with tabindex = 0 have lower tab order compared to elements\n   * with tabindex > 0.\n   * If both have same tabindex, it returns false.\n   * @param {!HTMLElement} a\n   * @param {!HTMLElement} b\n   * @return {boolean}\n   * @private\n   */\n  _hasLowerTabOrder: function(a, b) {\n    // Normalize tabIndexes\n    // e.g. in Firefox `<div contenteditable>` has `tabIndex = -1`\n    var ati = Math.max(a.tabIndex, 0);\n    var bti = Math.max(b.tabIndex, 0);\n    return (ati === 0 || bti === 0) ? bti > ati : ati > bti;\n  }\n};\n","/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\nimport '@polymer/polymer/polymer-legacy.js';\n\nimport {dom} from '@polymer/polymer/lib/legacy/polymer.dom.js';\n\n/**\n`Polymer.IronFitBehavior` fits an element in another element using `max-height`\nand `max-width`, and optionally centers it in the window or another element.\n\nThe element will only be sized and/or positioned if it has not already been\nsized and/or positioned by CSS.\n\nCSS properties            | Action\n--------------------------|-------------------------------------------\n`position` set            | Element is not centered horizontally or vertically\n`top` or `bottom` set     | Element is not vertically centered\n`left` or `right` set     | Element is not horizontally centered\n`max-height` set          | Element respects `max-height`\n`max-width` set           | Element respects `max-width`\n\n`Polymer.IronFitBehavior` can position an element into another element using\n`verticalAlign` and `horizontalAlign`. This will override the element's css\nposition.\n\n    <div class=\"container\">\n      <iron-fit-impl vertical-align=\"top\" horizontal-align=\"auto\">\n        Positioned into the container\n      </iron-fit-impl>\n    </div>\n\nUse `noOverlap` to position the element around another element without\noverlapping it.\n\n    <div class=\"container\">\n      <iron-fit-impl no-overlap vertical-align=\"auto\" horizontal-align=\"auto\">\n        Positioned around the container\n      </iron-fit-impl>\n    </div>\n\nUse `horizontalOffset, verticalOffset` to offset the element from its\n`positionTarget`; `Polymer.IronFitBehavior` will collapse these in order to\nkeep the element within `fitInto` boundaries, while preserving the element's\nCSS margin values.\n\n    <div class=\"container\">\n      <iron-fit-impl vertical-align=\"top\" vertical-offset=\"20\">\n        With vertical offset\n      </iron-fit-impl>\n    </div>\n\n@demo demo/index.html\n@polymerBehavior\n*/\nexport const IronFitBehavior = {\n\n  properties: {\n\n    /**\n     * The element that will receive a `max-height`/`width`. By default it is\n     * the same as `this`, but it can be set to a child element. This is useful,\n     * for example, for implementing a scrolling region inside the element.\n     * @type {!Element}\n     */\n    sizingTarget: {\n      type: Object,\n      value: function() {\n        return this;\n      }\n    },\n\n    /**\n     * The element to fit `this` into.\n     */\n    fitInto: {type: Object, value: window},\n\n    /**\n     * Will position the element around the positionTarget without overlapping\n     * it.\n     */\n    noOverlap: {type: Boolean},\n\n    /**\n     * The element that should be used to position the element. If not set, it\n     * will default to the parent node.\n     * @type {!Element}\n     */\n    positionTarget: {type: Element},\n\n    /**\n     * The orientation against which to align the element horizontally\n     * relative to the `positionTarget`. Possible values are \"left\", \"right\",\n     * \"center\", \"auto\".\n     */\n    horizontalAlign: {type: String},\n\n    /**\n     * The orientation against which to align the element vertically\n     * relative to the `positionTarget`. Possible values are \"top\", \"bottom\",\n     * \"middle\", \"auto\".\n     */\n    verticalAlign: {type: String},\n\n    /**\n     * If true, it will use `horizontalAlign` and `verticalAlign` values as\n     * preferred alignment and if there's not enough space, it will pick the\n     * values which minimize the cropping.\n     */\n    dynamicAlign: {type: Boolean},\n\n    /**\n     * A pixel value that will be added to the position calculated for the\n     * given `horizontalAlign`, in the direction of alignment. You can think\n     * of it as increasing or decreasing the distance to the side of the\n     * screen given by `horizontalAlign`.\n     *\n     * If `horizontalAlign` is \"left\" or \"center\", this offset will increase or\n     * decrease the distance to the left side of the screen: a negative offset\n     * will move the dropdown to the left; a positive one, to the right.\n     *\n     * Conversely if `horizontalAlign` is \"right\", this offset will increase\n     * or decrease the distance to the right side of the screen: a negative\n     * offset will move the dropdown to the right; a positive one, to the left.\n     */\n    horizontalOffset: {type: Number, value: 0, notify: true},\n\n    /**\n     * A pixel value that will be added to the position calculated for the\n     * given `verticalAlign`, in the direction of alignment. You can think\n     * of it as increasing or decreasing the distance to the side of the\n     * screen given by `verticalAlign`.\n     *\n     * If `verticalAlign` is \"top\" or \"middle\", this offset will increase or\n     * decrease the distance to the top side of the screen: a negative offset\n     * will move the dropdown upwards; a positive one, downwards.\n     *\n     * Conversely if `verticalAlign` is \"bottom\", this offset will increase\n     * or decrease the distance to the bottom side of the screen: a negative\n     * offset will move the dropdown downwards; a positive one, upwards.\n     */\n    verticalOffset: {type: Number, value: 0, notify: true},\n\n    /**\n     * Set to true to auto-fit on attach.\n     */\n    autoFitOnAttach: {type: Boolean, value: false},\n\n    /** @type {?Object} */\n    _fitInfo: {type: Object}\n  },\n\n  get _fitWidth() {\n    var fitWidth;\n    if (this.fitInto === window) {\n      fitWidth = this.fitInto.innerWidth;\n    } else {\n      fitWidth = this.fitInto.getBoundingClientRect().width;\n    }\n    return fitWidth;\n  },\n\n  get _fitHeight() {\n    var fitHeight;\n    if (this.fitInto === window) {\n      fitHeight = this.fitInto.innerHeight;\n    } else {\n      fitHeight = this.fitInto.getBoundingClientRect().height;\n    }\n    return fitHeight;\n  },\n\n  get _fitLeft() {\n    var fitLeft;\n    if (this.fitInto === window) {\n      fitLeft = 0;\n    } else {\n      fitLeft = this.fitInto.getBoundingClientRect().left;\n    }\n    return fitLeft;\n  },\n\n  get _fitTop() {\n    var fitTop;\n    if (this.fitInto === window) {\n      fitTop = 0;\n    } else {\n      fitTop = this.fitInto.getBoundingClientRect().top;\n    }\n    return fitTop;\n  },\n\n  /**\n   * The element that should be used to position the element,\n   * if no position target is configured.\n   */\n  get _defaultPositionTarget() {\n    var parent = dom(this).parentNode;\n\n    if (parent && parent.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n      parent = parent.host;\n    }\n\n    return parent;\n  },\n\n  /**\n   * The horizontal align value, accounting for the RTL/LTR text direction.\n   */\n  get _localeHorizontalAlign() {\n    if (this._isRTL) {\n      // In RTL, \"left\" becomes \"right\".\n      if (this.horizontalAlign === 'right') {\n        return 'left';\n      }\n      if (this.horizontalAlign === 'left') {\n        return 'right';\n      }\n    }\n    return this.horizontalAlign;\n  },\n\n  /**\n   * True if the element should be positioned instead of centered.\n   * @private\n   */\n  get __shouldPosition() {\n    return (this.horizontalAlign || this.verticalAlign) && this.positionTarget;\n  },\n\n  attached: function() {\n    // Memoize this to avoid expensive calculations & relayouts.\n    // Make sure we do it only once\n    if (typeof this._isRTL === 'undefined') {\n      this._isRTL = window.getComputedStyle(this).direction == 'rtl';\n    }\n    this.positionTarget = this.positionTarget || this._defaultPositionTarget;\n    if (this.autoFitOnAttach) {\n      if (window.getComputedStyle(this).display === 'none') {\n        setTimeout(function() {\n          this.fit();\n        }.bind(this));\n      } else {\n        // NOTE: shadydom applies distribution asynchronously\n        // for performance reasons webcomponents/shadydom#120\n        // Flush to get correct layout info.\n        window.ShadyDOM && ShadyDOM.flush();\n        this.fit();\n      }\n    }\n  },\n\n  detached: function() {\n    if (this.__deferredFit) {\n      clearTimeout(this.__deferredFit);\n      this.__deferredFit = null;\n    }\n  },\n\n  /**\n   * Positions and fits the element into the `fitInto` element.\n   */\n  fit: function() {\n    this.position();\n    this.constrain();\n    this.center();\n  },\n\n  /**\n   * Memoize information needed to position and size the target element.\n   * @suppress {deprecated}\n   */\n  _discoverInfo: function() {\n    if (this._fitInfo) {\n      return;\n    }\n    var target = window.getComputedStyle(this);\n    var sizer = window.getComputedStyle(this.sizingTarget);\n\n    this._fitInfo = {\n      inlineStyle: {\n        top: this.style.top || '',\n        left: this.style.left || '',\n        position: this.style.position || ''\n      },\n      sizerInlineStyle: {\n        maxWidth: this.sizingTarget.style.maxWidth || '',\n        maxHeight: this.sizingTarget.style.maxHeight || '',\n        boxSizing: this.sizingTarget.style.boxSizing || ''\n      },\n      positionedBy: {\n        vertically: target.top !== 'auto' ?\n            'top' :\n            (target.bottom !== 'auto' ? 'bottom' : null),\n        horizontally: target.left !== 'auto' ?\n            'left' :\n            (target.right !== 'auto' ? 'right' : null)\n      },\n      sizedBy: {\n        height: sizer.maxHeight !== 'none',\n        width: sizer.maxWidth !== 'none',\n        minWidth: parseInt(sizer.minWidth, 10) || 0,\n        minHeight: parseInt(sizer.minHeight, 10) || 0\n      },\n      margin: {\n        top: parseInt(target.marginTop, 10) || 0,\n        right: parseInt(target.marginRight, 10) || 0,\n        bottom: parseInt(target.marginBottom, 10) || 0,\n        left: parseInt(target.marginLeft, 10) || 0\n      }\n    };\n  },\n\n  /**\n   * Resets the target element's position and size constraints, and clear\n   * the memoized data.\n   */\n  resetFit: function() {\n    var info = this._fitInfo || {};\n    for (var property in info.sizerInlineStyle) {\n      this.sizingTarget.style[property] = info.sizerInlineStyle[property];\n    }\n    for (var property in info.inlineStyle) {\n      this.style[property] = info.inlineStyle[property];\n    }\n\n    this._fitInfo = null;\n  },\n\n  /**\n   * Equivalent to calling `resetFit()` and `fit()`. Useful to call this after\n   * the element or the `fitInto` element has been resized, or if any of the\n   * positioning properties (e.g. `horizontalAlign, verticalAlign`) is updated.\n   * It preserves the scroll position of the sizingTarget.\n   */\n  refit: function() {\n    var scrollLeft = this.sizingTarget.scrollLeft;\n    var scrollTop = this.sizingTarget.scrollTop;\n    this.resetFit();\n    this.fit();\n    this.sizingTarget.scrollLeft = scrollLeft;\n    this.sizingTarget.scrollTop = scrollTop;\n  },\n\n  /**\n   * Positions the element according to `horizontalAlign, verticalAlign`.\n   */\n  position: function() {\n    if (!this.__shouldPosition) {\n      // needs to be centered, and it is done after constrain.\n      return;\n    }\n    this._discoverInfo();\n\n    this.style.position = 'fixed';\n    // Need border-box for margin/padding.\n    this.sizingTarget.style.boxSizing = 'border-box';\n    // Set to 0, 0 in order to discover any offset caused by parent stacking\n    // contexts.\n    this.style.left = '0px';\n    this.style.top = '0px';\n\n    var rect = this.getBoundingClientRect();\n    var positionRect = this.__getNormalizedRect(this.positionTarget);\n    var fitRect = this.__getNormalizedRect(this.fitInto);\n\n    var margin = this._fitInfo.margin;\n\n    // Consider the margin as part of the size for position calculations.\n    var size = {\n      width: rect.width + margin.left + margin.right,\n      height: rect.height + margin.top + margin.bottom\n    };\n\n    var position = this.__getPosition(\n        this._localeHorizontalAlign,\n        this.verticalAlign,\n        size,\n        rect,\n        positionRect,\n        fitRect);\n\n    var left = position.left + margin.left;\n    var top = position.top + margin.top;\n\n    // We first limit right/bottom within fitInto respecting the margin,\n    // then use those values to limit top/left.\n    var right = Math.min(fitRect.right - margin.right, left + rect.width);\n    var bottom = Math.min(fitRect.bottom - margin.bottom, top + rect.height);\n\n    // Keep left/top within fitInto respecting the margin.\n    left = Math.max(\n        fitRect.left + margin.left,\n        Math.min(left, right - this._fitInfo.sizedBy.minWidth));\n    top = Math.max(\n        fitRect.top + margin.top,\n        Math.min(top, bottom - this._fitInfo.sizedBy.minHeight));\n\n    // Use right/bottom to set maxWidth/maxHeight, and respect\n    // minWidth/minHeight.\n    this.sizingTarget.style.maxWidth =\n        Math.max(right - left, this._fitInfo.sizedBy.minWidth) + 'px';\n    this.sizingTarget.style.maxHeight =\n        Math.max(bottom - top, this._fitInfo.sizedBy.minHeight) + 'px';\n\n    // Remove the offset caused by any stacking context.\n    this.style.left = (left - rect.left) + 'px';\n    this.style.top = (top - rect.top) + 'px';\n  },\n\n  /**\n   * Constrains the size of the element to `fitInto` by setting `max-height`\n   * and/or `max-width`.\n   */\n  constrain: function() {\n    if (this.__shouldPosition) {\n      return;\n    }\n    this._discoverInfo();\n\n    var info = this._fitInfo;\n    // position at (0px, 0px) if not already positioned, so we can measure the\n    // natural size.\n    if (!info.positionedBy.vertically) {\n      this.style.position = 'fixed';\n      this.style.top = '0px';\n    }\n    if (!info.positionedBy.horizontally) {\n      this.style.position = 'fixed';\n      this.style.left = '0px';\n    }\n\n    // need border-box for margin/padding\n    this.sizingTarget.style.boxSizing = 'border-box';\n    // constrain the width and height if not already set\n    var rect = this.getBoundingClientRect();\n    if (!info.sizedBy.height) {\n      this.__sizeDimension(\n          rect, info.positionedBy.vertically, 'top', 'bottom', 'Height');\n    }\n    if (!info.sizedBy.width) {\n      this.__sizeDimension(\n          rect, info.positionedBy.horizontally, 'left', 'right', 'Width');\n    }\n  },\n\n  /**\n   * @protected\n   * @deprecated\n   */\n  _sizeDimension: function(rect, positionedBy, start, end, extent) {\n    this.__sizeDimension(rect, positionedBy, start, end, extent);\n  },\n\n  /**\n   * @private\n   */\n  __sizeDimension: function(rect, positionedBy, start, end, extent) {\n    var info = this._fitInfo;\n    var fitRect = this.__getNormalizedRect(this.fitInto);\n    var max = extent === 'Width' ? fitRect.width : fitRect.height;\n    var flip = (positionedBy === end);\n    var offset = flip ? max - rect[end] : rect[start];\n    var margin = info.margin[flip ? start : end];\n    var offsetExtent = 'offset' + extent;\n    var sizingOffset = this[offsetExtent] - this.sizingTarget[offsetExtent];\n    this.sizingTarget.style['max' + extent] =\n        (max - margin - offset - sizingOffset) + 'px';\n  },\n\n  /**\n   * Centers horizontally and vertically if not already positioned. This also\n   * sets `position:fixed`.\n   */\n  center: function() {\n    if (this.__shouldPosition) {\n      return;\n    }\n    this._discoverInfo();\n\n    var positionedBy = this._fitInfo.positionedBy;\n    if (positionedBy.vertically && positionedBy.horizontally) {\n      // Already positioned.\n      return;\n    }\n    // Need position:fixed to center\n    this.style.position = 'fixed';\n    // Take into account the offset caused by parents that create stacking\n    // contexts (e.g. with transform: translate3d). Translate to 0,0 and\n    // measure the bounding rect.\n    if (!positionedBy.vertically) {\n      this.style.top = '0px';\n    }\n    if (!positionedBy.horizontally) {\n      this.style.left = '0px';\n    }\n    // It will take in consideration margins and transforms\n    var rect = this.getBoundingClientRect();\n    var fitRect = this.__getNormalizedRect(this.fitInto);\n    if (!positionedBy.vertically) {\n      var top = fitRect.top - rect.top + (fitRect.height - rect.height) / 2;\n      this.style.top = top + 'px';\n    }\n    if (!positionedBy.horizontally) {\n      var left = fitRect.left - rect.left + (fitRect.width - rect.width) / 2;\n      this.style.left = left + 'px';\n    }\n  },\n\n  __getNormalizedRect: function(target) {\n    if (target === document.documentElement || target === window) {\n      return {\n        top: 0,\n        left: 0,\n        width: window.innerWidth,\n        height: window.innerHeight,\n        right: window.innerWidth,\n        bottom: window.innerHeight\n      };\n    }\n    return target.getBoundingClientRect();\n  },\n\n  __getOffscreenArea: function(position, size, fitRect) {\n    var verticalCrop = Math.min(0, position.top) +\n        Math.min(0, fitRect.bottom - (position.top + size.height));\n    var horizontalCrop = Math.min(0, position.left) +\n        Math.min(0, fitRect.right - (position.left + size.width));\n    return Math.abs(verticalCrop) * size.width +\n        Math.abs(horizontalCrop) * size.height;\n  },\n\n\n  __getPosition: function(\n      hAlign, vAlign, size, sizeNoMargins, positionRect, fitRect) {\n    // All the possible configurations.\n    // Ordered as top-left, top-right, bottom-left, bottom-right.\n    var positions = [\n      {\n        verticalAlign: 'top',\n        horizontalAlign: 'left',\n        top: positionRect.top + this.verticalOffset,\n        left: positionRect.left + this.horizontalOffset\n      },\n      {\n        verticalAlign: 'top',\n        horizontalAlign: 'right',\n        top: positionRect.top + this.verticalOffset,\n        left: positionRect.right - size.width - this.horizontalOffset\n      },\n      {\n        verticalAlign: 'bottom',\n        horizontalAlign: 'left',\n        top: positionRect.bottom - size.height - this.verticalOffset,\n        left: positionRect.left + this.horizontalOffset\n      },\n      {\n        verticalAlign: 'bottom',\n        horizontalAlign: 'right',\n        top: positionRect.bottom - size.height - this.verticalOffset,\n        left: positionRect.right - size.width - this.horizontalOffset\n      }\n    ];\n\n    if (this.noOverlap) {\n      // Duplicate.\n      for (var i = 0, l = positions.length; i < l; i++) {\n        var copy = {};\n        for (var key in positions[i]) {\n          copy[key] = positions[i][key];\n        }\n        positions.push(copy);\n      }\n      // Horizontal overlap only.\n      positions[0].top = positions[1].top += positionRect.height;\n      positions[2].top = positions[3].top -= positionRect.height;\n      // Vertical overlap only.\n      positions[4].left = positions[6].left += positionRect.width;\n      positions[5].left = positions[7].left -= positionRect.width;\n    }\n\n    // Consider auto as null for coding convenience.\n    vAlign = vAlign === 'auto' ? null : vAlign;\n    hAlign = hAlign === 'auto' ? null : hAlign;\n\n    if (!hAlign || hAlign === 'center') {\n      positions.push({\n        verticalAlign: 'top',\n        horizontalAlign: 'center',\n        top: positionRect.top + this.verticalOffset +\n            (this.noOverlap ? positionRect.height : 0),\n        left: positionRect.left - sizeNoMargins.width / 2 +\n            positionRect.width / 2 + this.horizontalOffset\n      });\n      positions.push({\n        verticalAlign: 'bottom',\n        horizontalAlign: 'center',\n        top: positionRect.bottom - size.height - this.verticalOffset -\n            (this.noOverlap ? positionRect.height : 0),\n        left: positionRect.left - sizeNoMargins.width / 2 +\n            positionRect.width / 2 + this.horizontalOffset\n      });\n    }\n\n    if (!vAlign || vAlign === 'middle') {\n      positions.push({\n        verticalAlign: 'middle',\n        horizontalAlign: 'left',\n        top: positionRect.top - sizeNoMargins.height / 2 +\n            positionRect.height / 2 + this.verticalOffset,\n        left: positionRect.left + this.horizontalOffset +\n            (this.noOverlap ? positionRect.width : 0)\n      });\n      positions.push({\n        verticalAlign: 'middle',\n        horizontalAlign: 'right',\n        top: positionRect.top - sizeNoMargins.height / 2 +\n            positionRect.height / 2 + this.verticalOffset,\n        left: positionRect.right - size.width - this.horizontalOffset -\n            (this.noOverlap ? positionRect.width : 0)\n      });\n    }\n\n    if (vAlign === 'middle' && hAlign === 'center') {\n      positions.push({\n        verticalAlign: 'middle',\n        horizontalAlign: 'center',\n        top: positionRect.top - sizeNoMargins.height / 2 +\n            positionRect.height / 2 + this.verticalOffset,\n        left: positionRect.left - sizeNoMargins.width / 2 +\n            positionRect.width / 2 + this.horizontalOffset\n      });\n    }\n\n    var position;\n    for (var i = 0; i < positions.length; i++) {\n      var candidate = positions[i];\n      var vAlignOk = candidate.verticalAlign === vAlign;\n      var hAlignOk = candidate.horizontalAlign === hAlign;\n\n      // If both vAlign and hAlign are defined, return exact match.\n      // For dynamicAlign and noOverlap we'll have more than one candidate, so\n      // we'll have to check the offscreenArea to make the best choice.\n      if (!this.dynamicAlign && !this.noOverlap && vAlignOk && hAlignOk) {\n        position = candidate;\n        break;\n      }\n\n      // Align is ok if alignment preferences are respected. If no preferences,\n      // it is considered ok.\n      var alignOk = (!vAlign || vAlignOk) && (!hAlign || hAlignOk);\n\n      // Filter out elements that don't match the alignment (if defined).\n      // With dynamicAlign, we need to consider all the positions to find the\n      // one that minimizes the cropped area.\n      if (!this.dynamicAlign && !alignOk) {\n        continue;\n      }\n\n      candidate.offscreenArea =\n          this.__getOffscreenArea(candidate, size, fitRect);\n      // If not cropped and respects the align requirements, keep it.\n      // This allows to prefer positions overlapping horizontally over the\n      // ones overlapping vertically.\n      if (candidate.offscreenArea === 0 && alignOk) {\n        position = candidate;\n        break;\n      }\n      position = position || candidate;\n      var diff = candidate.offscreenArea - position.offscreenArea;\n      // Check which crops less. If it crops equally, check if at least one\n      // align setting is ok.\n      if (diff < 0 || (diff === 0 && (vAlignOk || hAlignOk))) {\n        position = candidate;\n      }\n    }\n\n    return position;\n  }\n\n};\n","/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\nimport '@polymer/polymer/polymer-legacy.js';\n\nimport {Polymer} from '@polymer/polymer/lib/legacy/polymer-fn.js';\nimport {dom} from '@polymer/polymer/lib/legacy/polymer.dom.js';\nimport {html} from '@polymer/polymer/lib/utils/html-tag.js';\n\n/*\n`iron-overlay-backdrop` is a backdrop used by `Polymer.IronOverlayBehavior`. It\nshould be a singleton.\n\n### Styling\n\nThe following custom properties and mixins are available for styling.\n\nCustom property | Description | Default\n-------------------------------------------|------------------------|---------\n`--iron-overlay-backdrop-background-color` | Backdrop background color | #000\n`--iron-overlay-backdrop-opacity`          | Backdrop opacity | 0.6\n`--iron-overlay-backdrop`                  | Mixin applied to `iron-overlay-backdrop`.                      | {}\n`--iron-overlay-backdrop-opened`           | Mixin applied to `iron-overlay-backdrop` when it is displayed | {}\n*/\nPolymer({\n  _template: html`\n    <style>\n      :host {\n        position: fixed;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n        background-color: var(--iron-overlay-backdrop-background-color, #000);\n        opacity: 0;\n        transition: opacity 0.2s;\n        pointer-events: none;\n        @apply --iron-overlay-backdrop;\n      }\n\n      :host(.opened) {\n        opacity: var(--iron-overlay-backdrop-opacity, 0.6);\n        pointer-events: auto;\n        @apply --iron-overlay-backdrop-opened;\n      }\n    </style>\n\n    <slot></slot>\n`,\n\n  is: 'iron-overlay-backdrop',\n\n  properties: {\n\n    /**\n     * Returns true if the backdrop is opened.\n     */\n    opened: {\n      reflectToAttribute: true,\n      type: Boolean,\n      value: false,\n      observer: '_openedChanged',\n    }\n\n  },\n\n  listeners: {\n    'transitionend': '_onTransitionend',\n  },\n\n  created: function() {\n    // Used to cancel previous requestAnimationFrame calls when opened changes.\n    this.__openedRaf = null;\n  },\n\n  attached: function() {\n    this.opened && this._openedChanged(this.opened);\n  },\n\n  /**\n   * Appends the backdrop to document body if needed.\n   */\n  prepare: function() {\n    if (this.opened && !this.parentNode) {\n      dom(document.body).appendChild(this);\n    }\n  },\n\n  /**\n   * Shows the backdrop.\n   */\n  open: function() {\n    this.opened = true;\n  },\n\n  /**\n   * Hides the backdrop.\n   */\n  close: function() {\n    this.opened = false;\n  },\n\n  /**\n   * Removes the backdrop from document body if needed.\n   */\n  complete: function() {\n    if (!this.opened && this.parentNode === document.body) {\n      dom(this.parentNode).removeChild(this);\n    }\n  },\n\n  _onTransitionend: function(event) {\n    if (event && event.target === this) {\n      this.complete();\n    }\n  },\n\n  /**\n   * @param {boolean} opened\n   * @private\n   */\n  _openedChanged: function(opened) {\n    if (opened) {\n      // Auto-attach.\n      this.prepare();\n    } else {\n      // Animation might be disabled via the mixin or opacity custom property.\n      // If it is disabled in other ways, it's up to the user to call complete.\n      var cs = window.getComputedStyle(this);\n      if (cs.transitionDuration === '0s' || cs.opacity == 0) {\n        this.complete();\n      }\n    }\n\n    if (!this.isAttached) {\n      return;\n    }\n\n    // Always cancel previous requestAnimationFrame.\n    if (this.__openedRaf) {\n      window.cancelAnimationFrame(this.__openedRaf);\n      this.__openedRaf = null;\n    }\n    // Force relayout to ensure proper transitions.\n    this.scrollTop = this.scrollTop;\n    this.__openedRaf = window.requestAnimationFrame(function() {\n      this.__openedRaf = null;\n      this.toggleClass('opened', this.opened);\n    }.bind(this));\n  }\n});\n","/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\nimport '@polymer/polymer/polymer-legacy.js';\nimport './iron-overlay-backdrop.js';\n\nimport {IronA11yKeysBehavior} from '@polymer/iron-a11y-keys-behavior/iron-a11y-keys-behavior.js';\nimport {dom} from '@polymer/polymer/lib/legacy/polymer.dom.js';\nimport * as gestures from '@polymer/polymer/lib/utils/gestures.js';\n\n/**\n * @struct\n * @constructor\n * @private\n */\nexport const IronOverlayManagerClass = function() {\n  /**\n   * Used to keep track of the opened overlays.\n   * @private {!Array<!Element>}\n   */\n  this._overlays = [];\n\n  /**\n   * iframes have a default z-index of 100,\n   * so this default should be at least that.\n   * @private {number}\n   */\n  this._minimumZ = 101;\n\n  /**\n   * Memoized backdrop element.\n   * @private {Element|null}\n   */\n  this._backdropElement = null;\n\n  // Enable document-wide tap recognizer.\n  // NOTE: Use useCapture=true to avoid accidentally prevention of the closing\n  // of an overlay via event.stopPropagation(). The only way to prevent\n  // closing of an overlay should be through its APIs.\n  // NOTE: enable tap on <html> to workaround Polymer/polymer#4459\n  // Pass no-op function because MSEdge 15 doesn't handle null as 2nd argument\n  // https://github.com/Microsoft/ChakraCore/issues/3863\n  gestures.add(document.documentElement, 'tap', function() {});\n  document.addEventListener('tap', this._onCaptureClick.bind(this), true);\n  document.addEventListener('focus', this._onCaptureFocus.bind(this), true);\n  document.addEventListener('keydown', this._onCaptureKeyDown.bind(this), true);\n};\n\nIronOverlayManagerClass.prototype = {\n\n  constructor: IronOverlayManagerClass,\n\n  /**\n   * The shared backdrop element.\n   * @return {!Element} backdropElement\n   */\n  get backdropElement() {\n    if (!this._backdropElement) {\n      this._backdropElement = document.createElement('iron-overlay-backdrop');\n    }\n    return this._backdropElement;\n  },\n\n  /**\n   * The deepest active element.\n   * @return {!Element} activeElement the active element\n   */\n  get deepActiveElement() {\n    var active = document.activeElement;\n    // document.activeElement can be null\n    // https://developer.mozilla.org/en-US/docs/Web/API/Document/activeElement\n    // In IE 11, it can also be an object when operating in iframes.\n    // In these cases, default it to document.body.\n    if (!active || active instanceof Element === false) {\n      active = document.body;\n    }\n    while (active.root && dom(active.root).activeElement) {\n      active = dom(active.root).activeElement;\n    }\n    return active;\n  },\n\n  /**\n   * Brings the overlay at the specified index to the front.\n   * @param {number} i\n   * @private\n   */\n  _bringOverlayAtIndexToFront: function(i) {\n    var overlay = this._overlays[i];\n    if (!overlay) {\n      return;\n    }\n    var lastI = this._overlays.length - 1;\n    var currentOverlay = this._overlays[lastI];\n    // Ensure always-on-top overlay stays on top.\n    if (currentOverlay &&\n        this._shouldBeBehindOverlay(overlay, currentOverlay)) {\n      lastI--;\n    }\n    // If already the top element, return.\n    if (i >= lastI) {\n      return;\n    }\n    // Update z-index to be on top.\n    var minimumZ = Math.max(this.currentOverlayZ(), this._minimumZ);\n    if (this._getZ(overlay) <= minimumZ) {\n      this._applyOverlayZ(overlay, minimumZ);\n    }\n\n    // Shift other overlays behind the new on top.\n    while (i < lastI) {\n      this._overlays[i] = this._overlays[i + 1];\n      i++;\n    }\n    this._overlays[lastI] = overlay;\n  },\n\n  /**\n   * Adds the overlay and updates its z-index if it's opened, or removes it if\n   * it's closed. Also updates the backdrop z-index.\n   * @param {!Element} overlay\n   */\n  addOrRemoveOverlay: function(overlay) {\n    if (overlay.opened) {\n      this.addOverlay(overlay);\n    } else {\n      this.removeOverlay(overlay);\n    }\n  },\n\n  /**\n   * Tracks overlays for z-index and focus management.\n   * Ensures the last added overlay with always-on-top remains on top.\n   * @param {!Element} overlay\n   */\n  addOverlay: function(overlay) {\n    var i = this._overlays.indexOf(overlay);\n    if (i >= 0) {\n      this._bringOverlayAtIndexToFront(i);\n      this.trackBackdrop();\n      return;\n    }\n    var insertionIndex = this._overlays.length;\n    var currentOverlay = this._overlays[insertionIndex - 1];\n    var minimumZ = Math.max(this._getZ(currentOverlay), this._minimumZ);\n    var newZ = this._getZ(overlay);\n\n    // Ensure always-on-top overlay stays on top.\n    if (currentOverlay &&\n        this._shouldBeBehindOverlay(overlay, currentOverlay)) {\n      // This bumps the z-index of +2.\n      this._applyOverlayZ(currentOverlay, minimumZ);\n      insertionIndex--;\n      // Update minimumZ to match previous overlay's z-index.\n      var previousOverlay = this._overlays[insertionIndex - 1];\n      minimumZ = Math.max(this._getZ(previousOverlay), this._minimumZ);\n    }\n\n    // Update z-index and insert overlay.\n    if (newZ <= minimumZ) {\n      this._applyOverlayZ(overlay, minimumZ);\n    }\n    this._overlays.splice(insertionIndex, 0, overlay);\n\n    this.trackBackdrop();\n  },\n\n  /**\n   * @param {!Element} overlay\n   */\n  removeOverlay: function(overlay) {\n    var i = this._overlays.indexOf(overlay);\n    if (i === -1) {\n      return;\n    }\n    this._overlays.splice(i, 1);\n\n    this.trackBackdrop();\n  },\n\n  /**\n   * Returns the current overlay.\n   * @return {!Element|undefined}\n   */\n  currentOverlay: function() {\n    var i = this._overlays.length - 1;\n    return this._overlays[i];\n  },\n\n  /**\n   * Returns the current overlay z-index.\n   * @return {number}\n   */\n  currentOverlayZ: function() {\n    return this._getZ(this.currentOverlay());\n  },\n\n  /**\n   * Ensures that the minimum z-index of new overlays is at least `minimumZ`.\n   * This does not effect the z-index of any existing overlays.\n   * @param {number} minimumZ\n   */\n  ensureMinimumZ: function(minimumZ) {\n    this._minimumZ = Math.max(this._minimumZ, minimumZ);\n  },\n\n  focusOverlay: function() {\n    var current = /** @type {?} */ (this.currentOverlay());\n    if (current) {\n      current._applyFocus();\n    }\n  },\n\n  /**\n   * Updates the backdrop z-index.\n   */\n  trackBackdrop: function() {\n    var overlay = this._overlayWithBackdrop();\n    // Avoid creating the backdrop if there is no overlay with backdrop.\n    if (!overlay && !this._backdropElement) {\n      return;\n    }\n    this.backdropElement.style.zIndex = this._getZ(overlay) - 1;\n    this.backdropElement.opened = !!overlay;\n    // Property observers are not fired until element is attached\n    // in Polymer 2.x, so we ensure element is attached if needed.\n    // https://github.com/Polymer/polymer/issues/4526\n    this.backdropElement.prepare();\n  },\n\n  /**\n   * @return {!Array<!Element>}\n   */\n  getBackdrops: function() {\n    var backdrops = [];\n    for (var i = 0; i < this._overlays.length; i++) {\n      if (this._overlays[i].withBackdrop) {\n        backdrops.push(this._overlays[i]);\n      }\n    }\n    return backdrops;\n  },\n\n  /**\n   * Returns the z-index for the backdrop.\n   * @return {number}\n   */\n  backdropZ: function() {\n    return this._getZ(this._overlayWithBackdrop()) - 1;\n  },\n\n  /**\n   * Returns the top opened overlay that has a backdrop.\n   * @return {!Element|undefined}\n   * @private\n   */\n  _overlayWithBackdrop: function() {\n    for (var i = this._overlays.length - 1; i >= 0; i--) {\n      if (this._overlays[i].withBackdrop) {\n        return this._overlays[i];\n      }\n    }\n  },\n\n  /**\n   * Calculates the minimum z-index for the overlay.\n   * @param {Element=} overlay\n   * @private\n   */\n  _getZ: function(overlay) {\n    var z = this._minimumZ;\n    if (overlay) {\n      var z1 = Number(\n          overlay.style.zIndex || window.getComputedStyle(overlay).zIndex);\n      // Check if is a number\n      // Number.isNaN not supported in IE 10+\n      if (z1 === z1) {\n        z = z1;\n      }\n    }\n    return z;\n  },\n\n  /**\n   * @param {!Element} element\n   * @param {number|string} z\n   * @private\n   */\n  _setZ: function(element, z) {\n    element.style.zIndex = z;\n  },\n\n  /**\n   * @param {!Element} overlay\n   * @param {number} aboveZ\n   * @private\n   */\n  _applyOverlayZ: function(overlay, aboveZ) {\n    this._setZ(overlay, aboveZ + 2);\n  },\n\n  /**\n   * Returns the deepest overlay in the path.\n   * @param {!Array<!Element>=} path\n   * @return {!Element|undefined}\n   * @suppress {missingProperties}\n   * @private\n   */\n  _overlayInPath: function(path) {\n    path = path || [];\n    for (var i = 0; i < path.length; i++) {\n      if (path[i]._manager === this) {\n        return path[i];\n      }\n    }\n  },\n\n  /**\n   * Ensures the click event is delegated to the right overlay.\n   * @param {!Event} event\n   * @private\n   */\n  _onCaptureClick: function(event) {\n    var i = this._overlays.length - 1;\n    if (i === -1)\n      return;\n    var path = /** @type {!Array<!EventTarget>} */ (dom(event).path);\n    var overlay;\n    // Check if clicked outside of overlay.\n    while ((overlay = /** @type {?} */ (this._overlays[i])) &&\n           this._overlayInPath(path) !== overlay) {\n      overlay._onCaptureClick(event);\n      if (overlay.allowClickThrough) {\n        i--;\n      } else {\n        break;\n      }\n    }\n  },\n\n  /**\n   * Ensures the focus event is delegated to the right overlay.\n   * @param {!Event} event\n   * @private\n   */\n  _onCaptureFocus: function(event) {\n    var overlay = /** @type {?} */ (this.currentOverlay());\n    if (overlay) {\n      overlay._onCaptureFocus(event);\n    }\n  },\n\n  /**\n   * Ensures TAB and ESC keyboard events are delegated to the right overlay.\n   * @param {!Event} event\n   * @private\n   */\n  _onCaptureKeyDown: function(event) {\n    var overlay = /** @type {?} */ (this.currentOverlay());\n    if (overlay) {\n      if (IronA11yKeysBehavior.keyboardEventMatchesKeys(event, 'esc')) {\n        overlay._onCaptureEsc(event);\n      } else if (IronA11yKeysBehavior.keyboardEventMatchesKeys(event, 'tab')) {\n        overlay._onCaptureTab(event);\n      }\n    }\n  },\n\n  /**\n   * Returns if the overlay1 should be behind overlay2.\n   * @param {!Element} overlay1\n   * @param {!Element} overlay2\n   * @return {boolean}\n   * @suppress {missingProperties}\n   * @private\n   */\n  _shouldBeBehindOverlay: function(overlay1, overlay2) {\n    return !overlay1.alwaysOnTop && overlay2.alwaysOnTop;\n  }\n};\n\nexport const IronOverlayManager = new IronOverlayManagerClass();\n","/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\nimport '@polymer/polymer/polymer-legacy.js';\n\nimport {dom} from '@polymer/polymer/lib/legacy/polymer.dom.js';\n/**\n * Used to calculate the scroll direction during touch events.\n * @type {!Object}\n */\nvar lastTouchPosition = {pageX: 0, pageY: 0};\n/**\n * Used to avoid computing event.path and filter scrollable nodes (better perf).\n * @type {?EventTarget}\n */\nvar lastRootTarget = null;\n/**\n * @type {!Array<!Node>}\n */\nvar lastScrollableNodes = [];\n/**\n * @type {!Array<string>}\n */\nvar scrollEvents = [\n  // Modern `wheel` event for mouse wheel scrolling:\n  'wheel',\n  // Older, non-standard `mousewheel` event for some FF:\n  'mousewheel',\n  // IE:\n  'DOMMouseScroll',\n  // Touch enabled devices\n  'touchstart',\n  'touchmove'\n];\n// must be defined for modulizer\nvar _boundScrollHandler;\nvar currentLockingElement;\n\n/**\n * The IronScrollManager is intended to provide a central source\n * of authority and control over which elements in a document are currently\n * allowed to scroll.\n *\n */\n`TODO(modulizer): A namespace named Polymer.IronScrollManager was\ndeclared here. The surrounding comments should be reviewed,\nand this string can then be deleted`;\n\n/**\n * The current element that defines the DOM boundaries of the\n * scroll lock. This is always the most recently locking element.\n *\n * @return {!Node|undefined}\n */\nexport {currentLockingElement};\n\n/**\n * Returns true if the provided element is \"scroll locked\", which is to\n * say that it cannot be scrolled via pointer or keyboard interactions.\n *\n * @param {!HTMLElement} element An HTML element instance which may or may\n * not be scroll locked.\n */\nexport function elementIsScrollLocked(element) {\n  var lockingElement = currentLockingElement;\n\n  if (lockingElement === undefined) {\n    return false;\n  }\n\n  var scrollLocked;\n\n  if (_hasCachedLockedElement(element)) {\n    return true;\n  }\n\n  if (_hasCachedUnlockedElement(element)) {\n    return false;\n  }\n\n  scrollLocked = !!lockingElement && lockingElement !== element &&\n      !_composedTreeContains(lockingElement, element);\n\n  if (scrollLocked) {\n    _lockedElementCache.push(element);\n  } else {\n    _unlockedElementCache.push(element);\n  }\n\n  return scrollLocked;\n}\n\n/**\n * Push an element onto the current scroll lock stack. The most recently\n * pushed element and its children will be considered scrollable. All\n * other elements will not be scrollable.\n *\n * Scroll locking is implemented as a stack so that cases such as\n * dropdowns within dropdowns are handled well.\n *\n * @param {!HTMLElement} element The element that should lock scroll.\n */\nexport function pushScrollLock(element) {\n  // Prevent pushing the same element twice\n  if (_lockingElements.indexOf(element) >= 0) {\n    return;\n  }\n\n  if (_lockingElements.length === 0) {\n    _lockScrollInteractions();\n  }\n\n  _lockingElements.push(element);\n  currentLockingElement = _lockingElements[_lockingElements.length - 1];\n\n  _lockedElementCache = [];\n  _unlockedElementCache = [];\n}\n\n/**\n * Remove an element from the scroll lock stack. The element being\n * removed does not need to be the most recently pushed element. However,\n * the scroll lock constraints only change when the most recently pushed\n * element is removed.\n *\n * @param {!HTMLElement} element The element to remove from the scroll\n * lock stack.\n */\nexport function removeScrollLock(element) {\n  var index = _lockingElements.indexOf(element);\n\n  if (index === -1) {\n    return;\n  }\n\n  _lockingElements.splice(index, 1);\n  currentLockingElement = _lockingElements[_lockingElements.length - 1];\n\n  _lockedElementCache = [];\n  _unlockedElementCache = [];\n\n  if (_lockingElements.length === 0) {\n    _unlockScrollInteractions();\n  }\n}\n\nexport const _lockingElements = [];\nexport let _lockedElementCache = null;\nexport let _unlockedElementCache = null;\n\nexport function _hasCachedLockedElement(element) {\n  return _lockedElementCache.indexOf(element) > -1;\n}\n\nexport function _hasCachedUnlockedElement(element) {\n  return _unlockedElementCache.indexOf(element) > -1;\n}\n\nexport function _composedTreeContains(element, child) {\n  // NOTE(cdata): This method iterates over content elements and their\n  // corresponding distributed nodes to implement a contains-like method\n  // that pierces through the composed tree of the ShadowDOM. Results of\n  // this operation are cached (elsewhere) on a per-scroll-lock basis, to\n  // guard against potentially expensive lookups happening repeatedly as\n  // a user scrolls / touchmoves.\n  var contentElements;\n  var distributedNodes;\n  var contentIndex;\n  var nodeIndex;\n\n  if (element.contains(child)) {\n    return true;\n  }\n\n  contentElements = dom(element).querySelectorAll('content,slot');\n\n  for (contentIndex = 0; contentIndex < contentElements.length;\n       ++contentIndex) {\n    distributedNodes = dom(contentElements[contentIndex]).getDistributedNodes();\n\n    for (nodeIndex = 0; nodeIndex < distributedNodes.length; ++nodeIndex) {\n      // Polymer 2.x returns slot.assignedNodes which can contain text nodes.\n      if (distributedNodes[nodeIndex].nodeType !== Node.ELEMENT_NODE)\n        continue;\n\n      if (_composedTreeContains(distributedNodes[nodeIndex], child)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nexport function _scrollInteractionHandler(event) {\n  // Avoid canceling an event with cancelable=false, e.g. scrolling is in\n  // progress and cannot be interrupted.\n  if (event.cancelable && _shouldPreventScrolling(event)) {\n    event.preventDefault();\n  }\n  // If event has targetTouches (touch event), update last touch position.\n  if (event.targetTouches) {\n    var touch = event.targetTouches[0];\n    lastTouchPosition.pageX = touch.pageX;\n    lastTouchPosition.pageY = touch.pageY;\n  }\n}\n\n/**\n * @private\n */\nexport {_boundScrollHandler};\n\nexport function _lockScrollInteractions() {\n  _boundScrollHandler =\n      _boundScrollHandler || _scrollInteractionHandler.bind(undefined);\n  for (var i = 0, l = scrollEvents.length; i < l; i++) {\n    // NOTE: browsers that don't support objects as third arg will\n    // interpret it as boolean, hence useCapture = true in this case.\n    document.addEventListener(\n        scrollEvents[i], _boundScrollHandler, {capture: true, passive: false});\n  }\n}\n\nexport function _unlockScrollInteractions() {\n  for (var i = 0, l = scrollEvents.length; i < l; i++) {\n    // NOTE: browsers that don't support objects as third arg will\n    // interpret it as boolean, hence useCapture = true in this case.\n    document.removeEventListener(\n        scrollEvents[i], _boundScrollHandler, {capture: true, passive: false});\n  }\n}\n\n/**\n * Returns true if the event causes scroll outside the current locking\n * element, e.g. pointer/keyboard interactions, or scroll \"leaking\"\n * outside the locking element when it is already at its scroll boundaries.\n * @param {!Event} event\n * @return {boolean}\n * @private\n */\nexport function _shouldPreventScrolling(event) {\n  // Update if root target changed. For touch events, ensure we don't\n  // update during touchmove.\n  var target = dom(event).rootTarget;\n  if (event.type !== 'touchmove' && lastRootTarget !== target) {\n    lastRootTarget = target;\n    lastScrollableNodes = _getScrollableNodes(dom(event).path);\n  }\n\n  // Prevent event if no scrollable nodes.\n  if (!lastScrollableNodes.length) {\n    return true;\n  }\n  // Don't prevent touchstart event inside the locking element when it has\n  // scrollable nodes.\n  if (event.type === 'touchstart') {\n    return false;\n  }\n  // Get deltaX/Y.\n  var info = _getScrollInfo(event);\n  // Prevent if there is no child that can scroll.\n  return !_getScrollingNode(lastScrollableNodes, info.deltaX, info.deltaY);\n}\n\n/**\n * Returns an array of scrollable nodes up to the current locking element,\n * which is included too if scrollable.\n * @param {!Array<!Node>} nodes\n * @return {!Array<!Node>} scrollables\n * @private\n */\nexport function _getScrollableNodes(nodes) {\n  var scrollables = [];\n  var lockingIndex = nodes.indexOf(currentLockingElement);\n  // Loop from root target to locking element (included).\n  for (var i = 0; i <= lockingIndex; i++) {\n    // Skip non-Element nodes.\n    if (nodes[i].nodeType !== Node.ELEMENT_NODE) {\n      continue;\n    }\n    var node = /** @type {!Element} */ (nodes[i]);\n    // Check inline style before checking computed style.\n    var style = node.style;\n    if (style.overflow !== 'scroll' && style.overflow !== 'auto') {\n      style = window.getComputedStyle(node);\n    }\n    if (style.overflow === 'scroll' || style.overflow === 'auto') {\n      scrollables.push(node);\n    }\n  }\n  return scrollables;\n}\n\n/**\n * Returns the node that is scrolling. If there is no scrolling,\n * returns undefined.\n * @param {!Array<!Node>} nodes\n * @param {number} deltaX Scroll delta on the x-axis\n * @param {number} deltaY Scroll delta on the y-axis\n * @return {!Node|undefined}\n * @private\n */\nexport function _getScrollingNode(nodes, deltaX, deltaY) {\n  // No scroll.\n  if (!deltaX && !deltaY) {\n    return;\n  }\n  // Check only one axis according to where there is more scroll.\n  // Prefer vertical to horizontal.\n  var verticalScroll = Math.abs(deltaY) >= Math.abs(deltaX);\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n    var canScroll = false;\n    if (verticalScroll) {\n      // delta < 0 is scroll up, delta > 0 is scroll down.\n      canScroll = deltaY < 0 ?\n          node.scrollTop > 0 :\n          node.scrollTop < node.scrollHeight - node.clientHeight;\n    } else {\n      // delta < 0 is scroll left, delta > 0 is scroll right.\n      canScroll = deltaX < 0 ?\n          node.scrollLeft > 0 :\n          node.scrollLeft < node.scrollWidth - node.clientWidth;\n    }\n    if (canScroll) {\n      return node;\n    }\n  }\n}\n\n/**\n * Returns scroll `deltaX` and `deltaY`.\n * @param {!Event} event The scroll event\n * @return {{deltaX: number, deltaY: number}} Object containing the\n * x-axis scroll delta (positive: scroll right, negative: scroll left,\n * 0: no scroll), and the y-axis scroll delta (positive: scroll down,\n * negative: scroll up, 0: no scroll).\n * @private\n */\nexport function _getScrollInfo(event) {\n  var info = {deltaX: event.deltaX, deltaY: event.deltaY};\n  // Already available.\n  if ('deltaX' in event) {\n    // do nothing, values are already good.\n  }\n  // Safari has scroll info in `wheelDeltaX/Y`.\n  else if ('wheelDeltaX' in event && 'wheelDeltaY' in event) {\n    info.deltaX = -event.wheelDeltaX;\n    info.deltaY = -event.wheelDeltaY;\n  }\n  // IE10 has only vertical scroll info in `wheelDelta`.\n  else if ('wheelDelta' in event) {\n    info.deltaX = 0;\n    info.deltaY = -event.wheelDelta;\n  }\n  // Firefox has scroll info in `detail` and `axis`.\n  else if ('axis' in event) {\n    info.deltaX = event.axis === 1 ? event.detail : 0;\n    info.deltaY = event.axis === 2 ? event.detail : 0;\n  }\n  // On mobile devices, calculate scroll direction.\n  else if (event.targetTouches) {\n    var touch = event.targetTouches[0];\n    // Touch moves from right to left => scrolling goes right.\n    info.deltaX = lastTouchPosition.pageX - touch.pageX;\n    // Touch moves from down to up => scrolling goes down.\n    info.deltaY = lastTouchPosition.pageY - touch.pageY;\n  }\n  return info;\n}\n","/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\nimport '@polymer/polymer/polymer-legacy.js';\n\nimport {IronFitBehavior} from '@polymer/iron-fit-behavior/iron-fit-behavior.js';\nimport {IronResizableBehavior} from '@polymer/iron-resizable-behavior/iron-resizable-behavior.js';\nimport {dom} from '@polymer/polymer/lib/legacy/polymer.dom.js';\nimport {useShadow} from '@polymer/polymer/lib/utils/settings.js';\n\nimport {IronFocusablesHelper} from './iron-focusables-helper.js';\nimport {IronOverlayManager} from './iron-overlay-manager.js';\nimport {pushScrollLock, removeScrollLock} from './iron-scroll-manager.js';\n\n/** @polymerBehavior */\nexport const IronOverlayBehaviorImpl = {\n\n  properties: {\n\n    /**\n     * True if the overlay is currently displayed.\n     */\n    opened:\n        {observer: '_openedChanged', type: Boolean, value: false, notify: true},\n\n    /**\n     * True if the overlay was canceled when it was last closed.\n     */\n    canceled: {\n      observer: '_canceledChanged',\n      readOnly: true,\n      type: Boolean,\n      value: false\n    },\n\n    /**\n     * Set to true to display a backdrop behind the overlay. It traps the focus\n     * within the light DOM of the overlay.\n     */\n    withBackdrop: {\n      observer: '_withBackdropChanged',\n      type: Boolean,\n    },\n\n    /**\n     * Set to true to disable auto-focusing the overlay or child nodes with\n     * the `autofocus` attribute` when the overlay is opened.\n     */\n    noAutoFocus: {\n      type: Boolean,\n      value: false,\n    },\n\n    /**\n     * Set to true to disable canceling the overlay with the ESC key.\n     */\n    noCancelOnEscKey: {\n      type: Boolean,\n      value: false,\n    },\n\n    /**\n     * Set to true to disable canceling the overlay by clicking outside it.\n     */\n    noCancelOnOutsideClick: {\n      type: Boolean,\n      value: false,\n    },\n\n    /**\n     * Contains the reason(s) this overlay was last closed (see\n     * `iron-overlay-closed`). `IronOverlayBehavior` provides the `canceled`\n     * reason; implementers of the behavior can provide other reasons in\n     * addition to `canceled`.\n     */\n    closingReason: {\n      // was a getter before, but needs to be a property so other\n      // behaviors can override this.\n      type: Object,\n    },\n\n    /**\n     * Set to true to enable restoring of focus when overlay is closed.\n     */\n    restoreFocusOnClose: {\n      type: Boolean,\n      value: false,\n    },\n\n    /**\n     * Set to true to allow clicks to go through overlays.\n     * When the user clicks outside this overlay, the click may\n     * close the overlay below.\n     */\n    allowClickThrough: {\n      type: Boolean,\n    },\n\n    /**\n     * Set to true to keep overlay always on top.\n     */\n    alwaysOnTop: {\n      type: Boolean,\n    },\n\n    /**\n     * Determines which action to perform when scroll outside an opened overlay\n     * happens. Possible values: lock - blocks scrolling from happening, refit -\n     * computes the new position on the overlay cancel - causes the overlay to\n     * close\n     */\n    scrollAction: {\n      type: String,\n    },\n\n    /**\n     * Shortcut to access to the overlay manager.\n     * @private\n     * @type {!IronOverlayManagerClass}\n     */\n    _manager: {\n      type: Object,\n      value: IronOverlayManager,\n    },\n\n    /**\n     * The node being focused.\n     * @type {?Node}\n     */\n    _focusedChild: {\n      type: Object,\n    }\n\n  },\n\n  listeners: {'iron-resize': '_onIronResize'},\n\n  observers: ['__updateScrollObservers(isAttached, opened, scrollAction)'],\n\n  /**\n   * The backdrop element.\n   * @return {!Element}\n   */\n  get backdropElement() {\n    return this._manager.backdropElement;\n  },\n\n  /**\n   * Returns the node to give focus to.\n   * @return {!Node}\n   */\n  get _focusNode() {\n    return this._focusedChild || dom(this).querySelector('[autofocus]') || this;\n  },\n\n  /**\n   * Array of nodes that can receive focus (overlay included), ordered by\n   * `tabindex`. This is used to retrieve which is the first and last focusable\n   * nodes in order to wrap the focus for overlays `with-backdrop`.\n   *\n   * If you know what is your content (specifically the first and last focusable\n   * children), you can override this method to return only `[firstFocusable,\n   * lastFocusable];`\n   * @return {!Array<!Node>}\n   * @protected\n   */\n  get _focusableNodes() {\n    return IronFocusablesHelper.getTabbableNodes(this);\n  },\n\n  /**\n   * @return {void}\n   */\n  ready: function() {\n    // Used to skip calls to notifyResize and refit while the overlay is\n    // animating.\n    this.__isAnimating = false;\n    // with-backdrop needs tabindex to be set in order to trap the focus.\n    // If it is not set, IronOverlayBehavior will set it, and remove it if\n    // with-backdrop = false.\n    this.__shouldRemoveTabIndex = false;\n    // Used for wrapping the focus on TAB / Shift+TAB.\n    this.__firstFocusableNode = this.__lastFocusableNode = null;\n    // Used by to keep track of the RAF callbacks.\n    this.__rafs = {};\n    // Focused node before overlay gets opened. Can be restored on close.\n    this.__restoreFocusNode = null;\n    // Scroll info to be restored.\n    this.__scrollTop = this.__scrollLeft = null;\n    this.__onCaptureScroll = this.__onCaptureScroll.bind(this);\n    // Root nodes hosting the overlay, used to listen for scroll events on them.\n    this.__rootNodes = null;\n    this._ensureSetup();\n  },\n\n  attached: function() {\n    // Call _openedChanged here so that position can be computed correctly.\n    if (this.opened) {\n      this._openedChanged(this.opened);\n    }\n    this._observer = dom(this).observeNodes(this._onNodesChange);\n  },\n\n  detached: function() {\n    dom(this).unobserveNodes(this._observer);\n    this._observer = null;\n    for (var cb in this.__rafs) {\n      if (this.__rafs[cb] !== null) {\n        cancelAnimationFrame(this.__rafs[cb]);\n      }\n    }\n    this.__rafs = {};\n    this._manager.removeOverlay(this);\n\n    // We got detached while animating, ensure we show/hide the overlay\n    // and fire iron-overlay-opened/closed event!\n    if (this.__isAnimating) {\n      if (this.opened) {\n        this._finishRenderOpened();\n      } else {\n        // Restore the focus if necessary.\n        this._applyFocus();\n        this._finishRenderClosed();\n      }\n    }\n  },\n\n  /**\n   * Toggle the opened state of the overlay.\n   */\n  toggle: function() {\n    this._setCanceled(false);\n    this.opened = !this.opened;\n  },\n\n  /**\n   * Open the overlay.\n   */\n  open: function() {\n    this._setCanceled(false);\n    this.opened = true;\n  },\n\n  /**\n   * Close the overlay.\n   */\n  close: function() {\n    this._setCanceled(false);\n    this.opened = false;\n  },\n\n  /**\n   * Cancels the overlay.\n   * @param {Event=} event The original event\n   */\n  cancel: function(event) {\n    var cancelEvent =\n        this.fire('iron-overlay-canceled', event, {cancelable: true});\n    if (cancelEvent.defaultPrevented) {\n      return;\n    }\n\n    this._setCanceled(true);\n    this.opened = false;\n  },\n\n  /**\n   * Invalidates the cached tabbable nodes. To be called when any of the\n   * focusable content changes (e.g. a button is disabled).\n   */\n  invalidateTabbables: function() {\n    this.__firstFocusableNode = this.__lastFocusableNode = null;\n  },\n\n  _ensureSetup: function() {\n    if (this._overlaySetup) {\n      return;\n    }\n    this._overlaySetup = true;\n    this.style.outline = 'none';\n    this.style.display = 'none';\n  },\n\n  /**\n   * Called when `opened` changes.\n   * @param {boolean=} opened\n   * @protected\n   */\n  _openedChanged: function(opened) {\n    if (opened) {\n      this.removeAttribute('aria-hidden');\n    } else {\n      this.setAttribute('aria-hidden', 'true');\n    }\n\n    // Defer any animation-related code on attached\n    // (_openedChanged gets called again on attached).\n    if (!this.isAttached) {\n      return;\n    }\n\n    this.__isAnimating = true;\n\n    // Deraf for non-blocking rendering.\n    this.__deraf('__openedChanged', this.__openedChanged);\n  },\n\n  _canceledChanged: function() {\n    this.closingReason = this.closingReason || {};\n    this.closingReason.canceled = this.canceled;\n  },\n\n  _withBackdropChanged: function() {\n    // If tabindex is already set, no need to override it.\n    if (this.withBackdrop && !this.hasAttribute('tabindex')) {\n      this.setAttribute('tabindex', '-1');\n      this.__shouldRemoveTabIndex = true;\n    } else if (this.__shouldRemoveTabIndex) {\n      this.removeAttribute('tabindex');\n      this.__shouldRemoveTabIndex = false;\n    }\n    if (this.opened && this.isAttached) {\n      this._manager.trackBackdrop();\n    }\n  },\n\n  /**\n   * tasks which must occur before opening; e.g. making the element visible.\n   * @protected\n   */\n  _prepareRenderOpened: function() {\n    // Store focused node.\n    this.__restoreFocusNode = this._manager.deepActiveElement;\n\n    // Needed to calculate the size of the overlay so that transitions on its\n    // size will have the correct starting points.\n    this._preparePositioning();\n    this.refit();\n    this._finishPositioning();\n\n    // Safari will apply the focus to the autofocus element when displayed\n    // for the first time, so we make sure to return the focus where it was.\n    if (this.noAutoFocus && document.activeElement === this._focusNode) {\n      this._focusNode.blur();\n      this.__restoreFocusNode.focus();\n    }\n  },\n\n  /**\n   * Tasks which cause the overlay to actually open; typically play an\n   * animation.\n   * @protected\n   */\n  _renderOpened: function() {\n    this._finishRenderOpened();\n  },\n\n  /**\n   * Tasks which cause the overlay to actually close; typically play an\n   * animation.\n   * @protected\n   */\n  _renderClosed: function() {\n    this._finishRenderClosed();\n  },\n\n  /**\n   * Tasks to be performed at the end of open action. Will fire\n   * `iron-overlay-opened`.\n   * @protected\n   */\n  _finishRenderOpened: function() {\n    this.notifyResize();\n    this.__isAnimating = false;\n\n    this.fire('iron-overlay-opened');\n  },\n\n  /**\n   * Tasks to be performed at the end of close action. Will fire\n   * `iron-overlay-closed`.\n   * @protected\n   */\n  _finishRenderClosed: function() {\n    // Hide the overlay.\n    this.style.display = 'none';\n    // Reset z-index only at the end of the animation.\n    this.style.zIndex = '';\n    this.notifyResize();\n    this.__isAnimating = false;\n    this.fire('iron-overlay-closed', this.closingReason);\n  },\n\n  _preparePositioning: function() {\n    this.style.transition = this.style.webkitTransition = 'none';\n    this.style.transform = this.style.webkitTransform = 'none';\n    this.style.display = '';\n  },\n\n  _finishPositioning: function() {\n    // First, make it invisible & reactivate animations.\n    this.style.display = 'none';\n    // Force reflow before re-enabling animations so that they don't start.\n    // Set scrollTop to itself so that Closure Compiler doesn't remove this.\n    this.scrollTop = this.scrollTop;\n    this.style.transition = this.style.webkitTransition = '';\n    this.style.transform = this.style.webkitTransform = '';\n    // Now that animations are enabled, make it visible again\n    this.style.display = '';\n    // Force reflow, so that following animations are properly started.\n    // Set scrollTop to itself so that Closure Compiler doesn't remove this.\n    this.scrollTop = this.scrollTop;\n  },\n\n  /**\n   * Applies focus according to the opened state.\n   * @protected\n   */\n  _applyFocus: function() {\n    if (this.opened) {\n      if (!this.noAutoFocus) {\n        this._focusNode.focus();\n      }\n    } else {\n      // Restore focus.\n      if (this.restoreFocusOnClose && this.__restoreFocusNode) {\n        // If the activeElement is `<body>` or inside the overlay,\n        // we are allowed to restore the focus. In all the other\n        // cases focus might have been moved elsewhere by another\n        // component or by an user interaction (e.g. click on a\n        // button outside the overlay).\n        var activeElement = this._manager.deepActiveElement;\n        if (activeElement === document.body ||\n            dom(this).deepContains(activeElement)) {\n          this.__restoreFocusNode.focus();\n        }\n      }\n      this.__restoreFocusNode = null;\n      this._focusNode.blur();\n      this._focusedChild = null;\n    }\n  },\n\n  /**\n   * Cancels (closes) the overlay. Call when click happens outside the overlay.\n   * @param {!Event} event\n   * @protected\n   */\n  _onCaptureClick: function(event) {\n    if (!this.noCancelOnOutsideClick) {\n      this.cancel(event);\n    }\n  },\n\n  /**\n   * Keeps track of the focused child. If withBackdrop, traps focus within\n   * overlay.\n   * @param {!Event} event\n   * @protected\n   */\n  _onCaptureFocus: function(event) {\n    if (!this.withBackdrop) {\n      return;\n    }\n    var path = dom(event).path;\n    if (path.indexOf(this) === -1) {\n      event.stopPropagation();\n      this._applyFocus();\n    } else {\n      this._focusedChild = path[0];\n    }\n  },\n\n  /**\n   * Handles the ESC key event and cancels (closes) the overlay.\n   * @param {!Event} event\n   * @protected\n   */\n  _onCaptureEsc: function(event) {\n    if (!this.noCancelOnEscKey) {\n      this.cancel(event);\n    }\n  },\n\n  /**\n   * Handles TAB key events to track focus changes.\n   * Will wrap focus for overlays withBackdrop.\n   * @param {!Event} event\n   * @protected\n   */\n  _onCaptureTab: function(event) {\n    if (!this.withBackdrop) {\n      return;\n    }\n    this.__ensureFirstLastFocusables();\n    // TAB wraps from last to first focusable.\n    // Shift + TAB wraps from first to last focusable.\n    var shift = event.shiftKey;\n    var nodeToCheck =\n        shift ? this.__firstFocusableNode : this.__lastFocusableNode;\n    var nodeToSet =\n        shift ? this.__lastFocusableNode : this.__firstFocusableNode;\n    var shouldWrap = false;\n    if (nodeToCheck === nodeToSet) {\n      // If nodeToCheck is the same as nodeToSet, it means we have an overlay\n      // with 0 or 1 focusables; in either case we still need to trap the\n      // focus within the overlay.\n      shouldWrap = true;\n    } else {\n      // In dom=shadow, the manager will receive focus changes on the main\n      // root but not the ones within other shadow roots, so we can't rely on\n      // _focusedChild, but we should check the deepest active element.\n      var focusedNode = this._manager.deepActiveElement;\n      // If the active element is not the nodeToCheck but the overlay itself,\n      // it means the focus is about to go outside the overlay, hence we\n      // should prevent that (e.g. user opens the overlay and hit Shift+TAB).\n      shouldWrap = (focusedNode === nodeToCheck || focusedNode === this);\n    }\n\n    if (shouldWrap) {\n      // When the overlay contains the last focusable element of the document\n      // and it's already focused, pressing TAB would move the focus outside\n      // the document (e.g. to the browser search bar). Similarly, when the\n      // overlay contains the first focusable element of the document and it's\n      // already focused, pressing Shift+TAB would move the focus outside the\n      // document (e.g. to the browser search bar).\n      // In both cases, we would not receive a focus event, but only a blur.\n      // In order to achieve focus wrapping, we prevent this TAB event and\n      // force the focus. This will also prevent the focus to temporarily move\n      // outside the overlay, which might cause scrolling.\n      event.preventDefault();\n      this._focusedChild = nodeToSet;\n      this._applyFocus();\n    }\n  },\n\n  /**\n   * Refits if the overlay is opened and not animating.\n   * @protected\n   */\n  _onIronResize: function() {\n    if (this.opened && !this.__isAnimating) {\n      this.__deraf('refit', this.refit);\n    }\n  },\n\n  /**\n   * Will call notifyResize if overlay is opened.\n   * Can be overridden in order to avoid multiple observers on the same node.\n   * @protected\n   */\n  _onNodesChange: function() {\n    if (this.opened && !this.__isAnimating) {\n      // It might have added focusable nodes, so invalidate cached values.\n      this.invalidateTabbables();\n      this.notifyResize();\n    }\n  },\n\n  /**\n   * Updates the references to the first and last focusable nodes.\n   * @private\n   */\n  __ensureFirstLastFocusables: function() {\n    var focusableNodes = this._focusableNodes;\n    this.__firstFocusableNode = focusableNodes[0];\n    this.__lastFocusableNode = focusableNodes[focusableNodes.length - 1];\n  },\n\n  /**\n   * Tasks executed when opened changes: prepare for the opening, move the\n   * focus, update the manager, render opened/closed.\n   * @private\n   */\n  __openedChanged: function() {\n    if (this.opened) {\n      // Make overlay visible, then add it to the manager.\n      this._prepareRenderOpened();\n      this._manager.addOverlay(this);\n      // Move the focus to the child node with [autofocus].\n      this._applyFocus();\n\n      this._renderOpened();\n    } else {\n      // Remove overlay, then restore the focus before actually closing.\n      this._manager.removeOverlay(this);\n      this._applyFocus();\n\n      this._renderClosed();\n    }\n  },\n\n  /**\n   * Debounces the execution of a callback to the next animation frame.\n   * @param {!string} jobname\n   * @param {!Function} callback Always bound to `this`\n   * @private\n   */\n  __deraf: function(jobname, callback) {\n    var rafs = this.__rafs;\n    if (rafs[jobname] !== null) {\n      cancelAnimationFrame(rafs[jobname]);\n    }\n    rafs[jobname] = requestAnimationFrame(function nextAnimationFrame() {\n      rafs[jobname] = null;\n      callback.call(this);\n    }.bind(this));\n  },\n\n  /**\n   * @param {boolean} isAttached\n   * @param {boolean} opened\n   * @param {string=} scrollAction\n   * @private\n   */\n  __updateScrollObservers: function(isAttached, opened, scrollAction) {\n    if (!isAttached || !opened || !this.__isValidScrollAction(scrollAction)) {\n      removeScrollLock(this);\n      this.__removeScrollListeners();\n    } else {\n      if (scrollAction === 'lock') {\n        this.__saveScrollPosition();\n        pushScrollLock(this);\n      }\n      this.__addScrollListeners();\n    }\n  },\n\n  /**\n   * @private\n   */\n  __addScrollListeners: function() {\n    if (!this.__rootNodes) {\n      this.__rootNodes = [];\n      // Listen for scroll events in all shadowRoots hosting this overlay only\n      // when in native ShadowDOM.\n      if (useShadow) {\n        var node = this;\n        while (node) {\n          if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && node.host) {\n            this.__rootNodes.push(node);\n          }\n          node = node.host || node.assignedSlot || node.parentNode;\n        }\n      }\n      this.__rootNodes.push(document);\n    }\n    this.__rootNodes.forEach(function(el) {\n      el.addEventListener('scroll', this.__onCaptureScroll, {\n        capture: true,\n        passive: true,\n      });\n    }, this);\n  },\n\n  /**\n   * @private\n   */\n  __removeScrollListeners: function() {\n    if (this.__rootNodes) {\n      this.__rootNodes.forEach(function(el) {\n        el.removeEventListener('scroll', this.__onCaptureScroll, {\n          capture: true,\n          passive: true,\n        });\n      }, this);\n    }\n    if (!this.isAttached) {\n      this.__rootNodes = null;\n    }\n  },\n\n  /**\n   * @param {string=} scrollAction\n   * @return {boolean}\n   * @private\n   */\n  __isValidScrollAction: function(scrollAction) {\n    return scrollAction === 'lock' || scrollAction === 'refit' ||\n        scrollAction === 'cancel';\n  },\n\n  /**\n   * @private\n   */\n  __onCaptureScroll: function(event) {\n    if (this.__isAnimating) {\n      return;\n    }\n    // Check if scroll outside the overlay.\n    if (dom(event).path.indexOf(this) >= 0) {\n      return;\n    }\n    switch (this.scrollAction) {\n      case 'lock':\n        // NOTE: scrolling might happen if a scroll event is not cancellable, or\n        // if user pressed keys that cause scrolling (they're not prevented in\n        // order not to break a11y features like navigate with arrow keys).\n        this.__restoreScrollPosition();\n        break;\n      case 'refit':\n        this.__deraf('refit', this.refit);\n        break;\n      case 'cancel':\n        this.cancel(event);\n        break;\n    }\n  },\n\n  /**\n   * Memoizes the scroll position of the outside scrolling element.\n   * @private\n   */\n  __saveScrollPosition: function() {\n    if (document.scrollingElement) {\n      this.__scrollTop = document.scrollingElement.scrollTop;\n      this.__scrollLeft = document.scrollingElement.scrollLeft;\n    } else {\n      // Since we don't know if is the body or html, get max.\n      this.__scrollTop =\n          Math.max(document.documentElement.scrollTop, document.body.scrollTop);\n      this.__scrollLeft = Math.max(\n          document.documentElement.scrollLeft, document.body.scrollLeft);\n    }\n  },\n\n  /**\n   * Resets the scroll position of the outside scrolling element.\n   * @private\n   */\n  __restoreScrollPosition: function() {\n    if (document.scrollingElement) {\n      document.scrollingElement.scrollTop = this.__scrollTop;\n      document.scrollingElement.scrollLeft = this.__scrollLeft;\n    } else {\n      // Since we don't know if is the body or html, set both.\n      document.documentElement.scrollTop = document.body.scrollTop =\n          this.__scrollTop;\n      document.documentElement.scrollLeft = document.body.scrollLeft =\n          this.__scrollLeft;\n    }\n  },\n\n};\n\n/**\n  Use `Polymer.IronOverlayBehavior` to implement an element that can be hidden\n  or shown, and displays on top of other content. It includes an optional\n  backdrop, and can be used to implement a variety of UI controls including\n  dialogs and drop downs. Multiple overlays may be displayed at once.\n\n  See the [demo source\n  code](https://github.com/PolymerElements/iron-overlay-behavior/blob/master/demo/simple-overlay.html)\n  for an example.\n\n  ### Closing and canceling\n\n  An overlay may be hidden by closing or canceling. The difference between close\n  and cancel is user intent. Closing generally implies that the user\n  acknowledged the content on the overlay. By default, it will cancel whenever\n  the user taps outside it or presses the escape key. This behavior is\n  configurable with the `no-cancel-on-esc-key` and the\n  `no-cancel-on-outside-click` properties. `close()` should be called explicitly\n  by the implementer when the user interacts with a control in the overlay\n  element. When the dialog is canceled, the overlay fires an\n  'iron-overlay-canceled' event. Call `preventDefault` on this event to prevent\n  the overlay from closing.\n\n  ### Positioning\n\n  By default the element is sized and positioned to fit and centered inside the\n  window. You can position and size it manually using CSS. See\n  `Polymer.IronFitBehavior`.\n\n  ### Backdrop\n\n  Set the `with-backdrop` attribute to display a backdrop behind the overlay.\n  The backdrop is appended to `<body>` and is of type `<iron-overlay-backdrop>`.\n  See its doc page for styling options.\n\n  In addition, `with-backdrop` will wrap the focus within the content in the\n  light DOM. Override the [`_focusableNodes`\n  getter](#Polymer.IronOverlayBehavior:property-_focusableNodes) to achieve a\n  different behavior.\n\n  ### Limitations\n\n  The element is styled to appear on top of other content by setting its\n  `z-index` property. You must ensure no element has a stacking context with a\n  higher `z-index` than its parent stacking context. You should place this\n  element as a child of `<body>` whenever possible.\n\n  @demo demo/index.html\n  @polymerBehavior\n */\nexport const IronOverlayBehavior =\n    [IronFitBehavior, IronResizableBehavior, IronOverlayBehaviorImpl];\n\n/**\n * Fired after the overlay opens.\n * @event iron-overlay-opened\n */\n\n/**\n * Fired when the overlay is canceled, but before it is closed.\n * @event iron-overlay-canceled\n * @param {Event} event The closing of the overlay can be prevented\n * by calling `event.preventDefault()`. The `event.detail` is the original event\n * that originated the canceling (e.g. ESC keyboard event or click event outside\n * the overlay).\n */\n\n/**\n * Fired after the overlay closes.\n * @event iron-overlay-closed\n * @param {Event} event The `event.detail` is the `closingReason` property\n * (contains `canceled`, whether the overlay was canceled).\n */\n","/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\nimport '@polymer/polymer/polymer-legacy.js';\n\n/**\n * `NeonAnimatableBehavior` is implemented by elements containing\n * animations for use with elements implementing\n * `NeonAnimationRunnerBehavior`.\n * @polymerBehavior\n */\nexport const NeonAnimatableBehavior = {\n\n  properties: {\n\n    /**\n     * Animation configuration. See README for more info.\n     */\n    animationConfig: {type: Object},\n\n    /**\n     * Convenience property for setting an 'entry' animation. Do not set\n     * `animationConfig.entry` manually if using this. The animated node is set\n     * to `this` if using this property.\n     */\n    entryAnimation: {\n      observer: '_entryAnimationChanged',\n      type: String,\n    },\n\n    /**\n     * Convenience property for setting an 'exit' animation. Do not set\n     * `animationConfig.exit` manually if using this. The animated node is set\n     * to `this` if using this property.\n     */\n    exitAnimation: {\n      observer: '_exitAnimationChanged',\n      type: String,\n    },\n\n  },\n\n  _entryAnimationChanged: function() {\n    this.animationConfig = this.animationConfig || {};\n    this.animationConfig['entry'] = [{name: this.entryAnimation, node: this}];\n  },\n\n  _exitAnimationChanged: function() {\n    this.animationConfig = this.animationConfig || {};\n    this.animationConfig['exit'] = [{name: this.exitAnimation, node: this}];\n  },\n\n  _copyProperties: function(config1, config2) {\n    // shallowly copy properties from config2 to config1\n    for (var property in config2) {\n      config1[property] = config2[property];\n    }\n  },\n\n  _cloneConfig: function(config) {\n    var clone = {isClone: true};\n    this._copyProperties(clone, config);\n    return clone;\n  },\n\n  _getAnimationConfigRecursive: function(type, map, allConfigs) {\n    if (!this.animationConfig) {\n      return;\n    }\n\n    if (this.animationConfig.value &&\n        typeof this.animationConfig.value === 'function') {\n      this._warn(this._logf(\n          'playAnimation',\n          'Please put \\'animationConfig\\' inside of your components \\'properties\\' object instead of outside of it.'));\n      return;\n    }\n\n    // type is optional\n    var thisConfig;\n    if (type) {\n      thisConfig = this.animationConfig[type];\n    } else {\n      thisConfig = this.animationConfig;\n    }\n\n    if (!Array.isArray(thisConfig)) {\n      thisConfig = [thisConfig];\n    }\n\n    // iterate animations and recurse to process configurations from child nodes\n    if (thisConfig) {\n      for (var config, index = 0; config = thisConfig[index]; index++) {\n        if (config.animatable) {\n          config.animatable._getAnimationConfigRecursive(\n              config.type || type, map, allConfigs);\n        } else {\n          if (config.id) {\n            var cachedConfig = map[config.id];\n            if (cachedConfig) {\n              // merge configurations with the same id, making a clone lazily\n              if (!cachedConfig.isClone) {\n                map[config.id] = this._cloneConfig(cachedConfig);\n                cachedConfig = map[config.id];\n              }\n              this._copyProperties(cachedConfig, config);\n            } else {\n              // put any configs with an id into a map\n              map[config.id] = config;\n            }\n          } else {\n            allConfigs.push(config);\n          }\n        }\n      }\n    }\n  },\n\n  /**\n   * An element implementing `NeonAnimationRunnerBehavior` calls this\n   * method to configure an animation with an optional type. Elements\n   * implementing `NeonAnimatableBehavior` should define the property\n   * `animationConfig`, which is either a configuration object or a map of\n   * animation type to array of configuration objects.\n   */\n  getAnimationConfig: function(type) {\n    var map = {};\n    var allConfigs = [];\n    this._getAnimationConfigRecursive(type, map, allConfigs);\n    // append the configurations saved in the map to the array\n    for (var key in map) {\n      allConfigs.push(map[key]);\n    }\n    return allConfigs;\n  }\n\n};\n","/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\nimport '@polymer/polymer/polymer-legacy.js';\n\nimport {NeonAnimatableBehavior} from './neon-animatable-behavior.js';\n\n/**\n * `NeonAnimationRunnerBehavior` adds a method to run animations.\n *\n * @polymerBehavior NeonAnimationRunnerBehavior\n */\nexport const NeonAnimationRunnerBehaviorImpl = {\n\n  _configureAnimations: function(configs) {\n    var results = [];\n    var resultsToPlay = [];\n\n    if (configs.length > 0) {\n      for (let config, index = 0; config = configs[index]; index++) {\n        let neonAnimation = document.createElement(config.name);\n        // is this element actually a neon animation?\n        if (neonAnimation.isNeonAnimation) {\n          let result = null;\n          // Closure compiler does not work well with a try / catch here.\n          // .configure needs to be explicitly defined\n          if (!neonAnimation.configure) {\n            /**\n             * @param {Object} config\n             * @return {AnimationEffectReadOnly}\n             */\n            neonAnimation.configure = function(config) {\n              return null;\n            }\n          }\n\n          result = neonAnimation.configure(config);\n          resultsToPlay.push({\n            result: result,\n            config: config,\n            neonAnimation: neonAnimation,\n          });\n        } else {\n          console.warn(this.is + ':', config.name, 'not found!');\n        }\n      }\n    }\n\n    for (var i = 0; i < resultsToPlay.length; i++) {\n      let result = resultsToPlay[i].result;\n      let config = resultsToPlay[i].config;\n      let neonAnimation = resultsToPlay[i].neonAnimation;\n      // configuration or play could fail if polyfills aren't loaded\n      try {\n        // Check if we have an Effect rather than an Animation\n        if (typeof result.cancel != 'function') {\n          result = document.timeline.play(result);\n        }\n      } catch (e) {\n        result = null;\n        console.warn('Couldnt play', '(', config.name, ').', e);\n      }\n\n      if (result) {\n        results.push({\n          neonAnimation: neonAnimation,\n          config: config,\n          animation: result,\n        });\n      }\n    }\n\n    return results;\n  },\n\n  _shouldComplete: function(activeEntries) {\n    var finished = true;\n    for (var i = 0; i < activeEntries.length; i++) {\n      if (activeEntries[i].animation.playState != 'finished') {\n        finished = false;\n        break;\n      }\n    }\n    return finished;\n  },\n\n  _complete: function(activeEntries) {\n    for (var i = 0; i < activeEntries.length; i++) {\n      activeEntries[i].neonAnimation.complete(activeEntries[i].config);\n    }\n    for (var i = 0; i < activeEntries.length; i++) {\n      activeEntries[i].animation.cancel();\n    }\n  },\n\n  /**\n   * Plays an animation with an optional `type`.\n   * @param {string=} type\n   * @param {!Object=} cookie\n   */\n  playAnimation: function(type, cookie) {\n    var configs = this.getAnimationConfig(type);\n    if (!configs) {\n      return;\n    }\n    this._active = this._active || {};\n    if (this._active[type]) {\n      this._complete(this._active[type]);\n      delete this._active[type];\n    }\n\n    var activeEntries = this._configureAnimations(configs);\n\n    if (activeEntries.length == 0) {\n      this.fire('neon-animation-finish', cookie, {bubbles: false});\n      return;\n    }\n\n    this._active[type] = activeEntries;\n\n    for (var i = 0; i < activeEntries.length; i++) {\n      activeEntries[i].animation.onfinish = function() {\n        if (this._shouldComplete(activeEntries)) {\n          this._complete(activeEntries);\n          delete this._active[type];\n          this.fire('neon-animation-finish', cookie, {bubbles: false});\n        }\n      }.bind(this);\n    }\n  },\n\n  /**\n   * Cancels the currently running animations.\n   */\n  cancelAnimation: function() {\n    for (var k in this._active) {\n      var entries = this._active[k]\n\n                    for (var j in entries) {\n        entries[j].animation.cancel();\n      }\n    }\n\n    this._active = {};\n  }\n};\n\n/** @polymerBehavior */\nexport const NeonAnimationRunnerBehavior =\n    [NeonAnimatableBehavior, NeonAnimationRunnerBehaviorImpl];\n"],"sourceRoot":""}