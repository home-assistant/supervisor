{"version":3,"file":"14f71221.js","mappings":";;;AAkBA;AACA;;AAEA;;AAGA;AAGA;;;;;;;;;;;;;;;;;;;;;;AAtBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACgCA;;ACwEA;AACA;AACA;AACA;AACA;;AAEA;AAnEA;;;;;AAAA;;;AClBA;AACA;AACA;AACA;AACA;;AArBA;;;;;AAAA","sources":["webpack://home-assistant-frontend/./src/components/map/ha-entity-marker.ts","webpack://home-assistant-frontend/./src/components/map/ha-map.ts","webpack://home-assistant-frontend/./src/components/map/ha-locations-editor.ts","webpack://home-assistant-frontend/./src/components/ha-selector/ha-selector-location.ts"],"sourcesContent":["import { LitElement, html, css } from \"lit\";\nimport { property } from \"lit/decorators\";\nimport { styleMap } from \"lit/directives/style-map\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\n\nclass HaEntityMarker extends LitElement {\n  @property({ attribute: \"entity-id\" }) public entityId?: string;\n\n  @property({ attribute: \"entity-name\" }) public entityName?: string;\n\n  @property({ attribute: \"entity-picture\" }) public entityPicture?: string;\n\n  @property({ attribute: \"entity-color\" }) public entityColor?: string;\n\n  protected render() {\n    return html`\n      <div\n        class=\"marker\"\n        style=${styleMap({ \"border-color\": this.entityColor })}\n        @click=${this._badgeTap}\n      >\n        ${this.entityPicture\n          ? html`<div\n              class=\"entity-picture\"\n              style=${styleMap({\n                \"background-image\": `url(${this.entityPicture})`,\n              })}\n            ></div>`\n          : this.entityName}\n      </div>\n    `;\n  }\n\n  private _badgeTap(ev: Event) {\n    ev.stopPropagation();\n    if (this.entityId) {\n      fireEvent(this, \"hass-more-info\", { entityId: this.entityId });\n    }\n  }\n\n  static get styles() {\n    return css`\n      .marker {\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        box-sizing: border-box;\n        overflow: hidden;\n        width: 48px;\n        height: 48px;\n        font-size: var(--ha-marker-font-size, 1.5em);\n        border-radius: 50%;\n        border: 1px solid var(--ha-marker-color, var(--primary-color));\n        color: var(--primary-text-color);\n        background-color: var(--card-background-color);\n      }\n      .entity-picture {\n        background-size: cover;\n        height: 100%;\n        width: 100%;\n      }\n    `;\n  }\n}\n\ncustomElements.define(\"ha-entity-marker\", HaEntityMarker);\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-entity-marker\": HaEntityMarker;\n  }\n}\n","import {\n  Circle,\n  CircleMarker,\n  LatLngTuple,\n  Layer,\n  Map,\n  Marker,\n  Polyline,\n} from \"leaflet\";\nimport { css, CSSResultGroup, PropertyValues, ReactiveElement } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport {\n  LeafletModuleType,\n  setupLeafletMap,\n} from \"../../common/dom/setup-leaflet-map\";\nimport { computeStateDomain } from \"../../common/entity/compute_state_domain\";\nimport { computeStateName } from \"../../common/entity/compute_state_name\";\nimport { installResizeObserver } from \"../../panels/lovelace/common/install-resize-observer\";\nimport { HomeAssistant } from \"../../types\";\nimport \"../ha-icon-button\";\nimport \"./ha-entity-marker\";\n\nconst getEntityId = (entity: string | HaMapEntity): string =>\n  typeof entity === \"string\" ? entity : entity.entity_id;\n\nexport interface HaMapPaths {\n  points: LatLngTuple[];\n  color?: string;\n  gradualOpacity?: number;\n}\n\nexport interface HaMapEntity {\n  entity_id: string;\n  color: string;\n}\n\n@customElement(\"ha-map\")\nexport class HaMap extends ReactiveElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public entities?: string[] | HaMapEntity[];\n\n  @property({ attribute: false }) public paths?: HaMapPaths[];\n\n  @property({ attribute: false }) public layers?: Layer[];\n\n  @property({ type: Boolean }) public autoFit = false;\n\n  @property({ type: Boolean }) public fitZones?: boolean;\n\n  @property({ type: Boolean }) public darkMode?: boolean;\n\n  @property({ type: Number }) public zoom = 14;\n\n  @state() private _loaded = false;\n\n  public leafletMap?: Map;\n\n  private Leaflet?: LeafletModuleType;\n\n  private _resizeObserver?: ResizeObserver;\n\n  private _mapItems: Array<Marker | Circle> = [];\n\n  private _mapZones: Array<Marker | Circle> = [];\n\n  private _mapPaths: Array<Polyline | CircleMarker> = [];\n\n  public connectedCallback(): void {\n    super.connectedCallback();\n    this._loadMap();\n    this._attachObserver();\n  }\n\n  public disconnectedCallback(): void {\n    super.disconnectedCallback();\n    if (this.leafletMap) {\n      this.leafletMap.remove();\n      this.leafletMap = undefined;\n      this.Leaflet = undefined;\n    }\n\n    this._loaded = false;\n\n    if (this._resizeObserver) {\n      this._resizeObserver.unobserve(this);\n    }\n  }\n\n  protected update(changedProps: PropertyValues) {\n    super.update(changedProps);\n\n    if (!this._loaded) {\n      return;\n    }\n    const oldHass = changedProps.get(\"hass\") as HomeAssistant | undefined;\n\n    if (changedProps.has(\"_loaded\") || changedProps.has(\"entities\")) {\n      this._drawEntities();\n    } else if (this._loaded && oldHass && this.entities) {\n      // Check if any state has changed\n      for (const entity of this.entities) {\n        if (\n          oldHass.states[getEntityId(entity)] !==\n          this.hass!.states[getEntityId(entity)]\n        ) {\n          this._drawEntities();\n          break;\n        }\n      }\n    }\n\n    if (changedProps.has(\"_loaded\") || changedProps.has(\"paths\")) {\n      this._drawPaths();\n    }\n\n    if (changedProps.has(\"_loaded\") || changedProps.has(\"layers\")) {\n      this._drawLayers(changedProps.get(\"layers\") as Layer[] | undefined);\n    }\n\n    if (\n      changedProps.has(\"_loaded\") ||\n      ((changedProps.has(\"entities\") || changedProps.has(\"layers\")) &&\n        this.autoFit)\n    ) {\n      this.fitMap();\n    }\n\n    if (changedProps.has(\"zoom\")) {\n      this.leafletMap!.setZoom(this.zoom);\n    }\n\n    if (\n      !changedProps.has(\"darkMode\") &&\n      (!changedProps.has(\"hass\") ||\n        (oldHass && oldHass.themes.darkMode === this.hass.themes.darkMode))\n    ) {\n      return;\n    }\n    const darkMode = this.darkMode ?? this.hass.themes.darkMode;\n    this.shadowRoot!.getElementById(\"map\")!.classList.toggle(\"dark\", darkMode);\n  }\n\n  private async _loadMap(): Promise<void> {\n    let map = this.shadowRoot!.getElementById(\"map\");\n    if (!map) {\n      map = document.createElement(\"div\");\n      map.id = \"map\";\n      this.shadowRoot!.append(map);\n    }\n    const darkMode = this.darkMode ?? this.hass.themes.darkMode;\n    [this.leafletMap, this.Leaflet] = await setupLeafletMap(map);\n    this.shadowRoot!.getElementById(\"map\")!.classList.toggle(\"dark\", darkMode);\n    this._loaded = true;\n  }\n\n  public fitMap(): void {\n    if (!this.leafletMap || !this.Leaflet || !this.hass) {\n      return;\n    }\n\n    if (!this._mapItems.length && !this.layers?.length) {\n      this.leafletMap.setView(\n        new this.Leaflet.LatLng(\n          this.hass.config.latitude,\n          this.hass.config.longitude\n        ),\n        this.zoom\n      );\n      return;\n    }\n\n    let bounds = this.Leaflet.latLngBounds(\n      this._mapItems ? this._mapItems.map((item) => item.getLatLng()) : []\n    );\n\n    if (this.fitZones) {\n      this._mapZones?.forEach((zone) => {\n        bounds.extend(\n          \"getBounds\" in zone ? zone.getBounds() : zone.getLatLng()\n        );\n      });\n    }\n\n    this.layers?.forEach((layer: any) => {\n      bounds.extend(\n        \"getBounds\" in layer ? layer.getBounds() : layer.getLatLng()\n      );\n    });\n\n    if (!this.layers) {\n      bounds = bounds.pad(0.5);\n    }\n\n    this.leafletMap.fitBounds(bounds, { maxZoom: this.zoom });\n  }\n\n  private _drawLayers(prevLayers: Layer[] | undefined): void {\n    if (prevLayers) {\n      prevLayers.forEach((layer) => layer.remove());\n    }\n    if (!this.layers) {\n      return;\n    }\n    const map = this.leafletMap!;\n    this.layers.forEach((layer) => {\n      map.addLayer(layer);\n    });\n  }\n\n  private _drawPaths(): void {\n    const hass = this.hass;\n    const map = this.leafletMap;\n    const Leaflet = this.Leaflet;\n\n    if (!hass || !map || !Leaflet) {\n      return;\n    }\n    if (this._mapPaths.length) {\n      this._mapPaths.forEach((marker) => marker.remove());\n      this._mapPaths = [];\n    }\n    if (!this.paths) {\n      return;\n    }\n\n    const darkPrimaryColor = getComputedStyle(this).getPropertyValue(\n      \"--dark-primary-color\"\n    );\n\n    this.paths.forEach((path) => {\n      let opacityStep: number;\n      let baseOpacity: number;\n      if (path.gradualOpacity) {\n        opacityStep = path.gradualOpacity / (path.points.length - 2);\n        baseOpacity = 1 - path.gradualOpacity;\n      }\n\n      for (\n        let pointIndex = 0;\n        pointIndex < path.points.length - 1;\n        pointIndex++\n      ) {\n        const opacity = path.gradualOpacity\n          ? baseOpacity! + pointIndex * opacityStep!\n          : undefined;\n\n        // DRAW point\n        this._mapPaths.push(\n          Leaflet!.circleMarker(path.points[pointIndex], {\n            radius: 3,\n            color: path.color || darkPrimaryColor,\n            opacity,\n            fillOpacity: opacity,\n            interactive: false,\n          })\n        );\n\n        // DRAW line between this and next point\n        this._mapPaths.push(\n          Leaflet!.polyline(\n            [path.points[pointIndex], path.points[pointIndex + 1]],\n            {\n              color: path.color || darkPrimaryColor,\n              opacity,\n              interactive: false,\n            }\n          )\n        );\n      }\n      const pointIndex = path.points.length - 1;\n      if (pointIndex >= 0) {\n        const opacity = path.gradualOpacity\n          ? baseOpacity! + pointIndex * opacityStep!\n          : undefined;\n        // DRAW end path point\n        this._mapPaths.push(\n          Leaflet!.circleMarker(path.points[pointIndex], {\n            radius: 3,\n            color: path.color || darkPrimaryColor,\n            opacity,\n            fillOpacity: opacity,\n            interactive: false,\n          })\n        );\n      }\n      this._mapPaths.forEach((marker) => map.addLayer(marker));\n    });\n  }\n\n  private _drawEntities(): void {\n    const hass = this.hass;\n    const map = this.leafletMap;\n    const Leaflet = this.Leaflet;\n\n    if (!hass || !map || !Leaflet) {\n      return;\n    }\n\n    if (this._mapItems.length) {\n      this._mapItems.forEach((marker) => marker.remove());\n      this._mapItems = [];\n    }\n\n    if (this._mapZones.length) {\n      this._mapZones.forEach((marker) => marker.remove());\n      this._mapZones = [];\n    }\n\n    if (!this.entities) {\n      return;\n    }\n\n    const computedStyles = getComputedStyle(this);\n    const zoneColor = computedStyles.getPropertyValue(\"--accent-color\");\n    const darkPrimaryColor = computedStyles.getPropertyValue(\n      \"--dark-primary-color\"\n    );\n\n    const className =\n      this.darkMode ?? this.hass.themes.darkMode ? \"dark\" : \"light\";\n\n    for (const entity of this.entities) {\n      const stateObj = hass.states[getEntityId(entity)];\n      if (!stateObj) {\n        continue;\n      }\n      const title = computeStateName(stateObj);\n      const {\n        latitude,\n        longitude,\n        passive,\n        icon,\n        radius,\n        entity_picture: entityPicture,\n        gps_accuracy: gpsAccuracy,\n      } = stateObj.attributes;\n\n      if (!(latitude && longitude)) {\n        continue;\n      }\n\n      if (computeStateDomain(stateObj) === \"zone\") {\n        // DRAW ZONE\n        if (passive) {\n          continue;\n        }\n\n        // create icon\n        let iconHTML = \"\";\n        if (icon) {\n          const el = document.createElement(\"ha-icon\");\n          el.setAttribute(\"icon\", icon);\n          iconHTML = el.outerHTML;\n        } else {\n          const el = document.createElement(\"span\");\n          el.innerHTML = title;\n          iconHTML = el.outerHTML;\n        }\n\n        // create marker with the icon\n        this._mapZones.push(\n          Leaflet.marker([latitude, longitude], {\n            icon: Leaflet.divIcon({\n              html: iconHTML,\n              iconSize: [24, 24],\n              className,\n            }),\n            interactive: false,\n            title,\n          })\n        );\n\n        // create circle around it\n        this._mapZones.push(\n          Leaflet.circle([latitude, longitude], {\n            interactive: false,\n            color: zoneColor,\n            radius,\n          })\n        );\n\n        continue;\n      }\n\n      // DRAW ENTITY\n      // create icon\n      const entityName = title\n        .split(\" \")\n        .map((part) => part[0])\n        .join(\"\")\n        .substr(0, 3);\n\n      // create marker with the icon\n      this._mapItems.push(\n        Leaflet.marker([latitude, longitude], {\n          icon: Leaflet.divIcon({\n            html: `\n              <ha-entity-marker\n                entity-id=\"${getEntityId(entity)}\"\n                entity-name=\"${entityName}\"\n                entity-picture=\"${\n                  entityPicture ? this.hass.hassUrl(entityPicture) : \"\"\n                }\"\n                ${\n                  typeof entity !== \"string\"\n                    ? `entity-color=\"${entity.color}\"`\n                    : \"\"\n                }\n              ></ha-entity-marker>\n            `,\n            iconSize: [48, 48],\n            className: \"\",\n          }),\n          title: computeStateName(stateObj),\n        })\n      );\n\n      // create circle around if entity has accuracy\n      if (gpsAccuracy) {\n        this._mapItems.push(\n          Leaflet.circle([latitude, longitude], {\n            interactive: false,\n            color: darkPrimaryColor,\n            radius: gpsAccuracy,\n          })\n        );\n      }\n    }\n\n    this._mapItems.forEach((marker) => map.addLayer(marker));\n    this._mapZones.forEach((marker) => map.addLayer(marker));\n  }\n\n  private async _attachObserver(): Promise<void> {\n    if (!this._resizeObserver) {\n      await installResizeObserver();\n      this._resizeObserver = new ResizeObserver(() => {\n        this.leafletMap?.invalidateSize({ debounceMoveend: true });\n      });\n    }\n    this._resizeObserver.observe(this);\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        display: block;\n        height: 300px;\n      }\n      #map {\n        height: 100%;\n      }\n      #map.dark {\n        background: #090909;\n        --map-filter: invert(0.9) hue-rotate(170deg) grayscale(0.7);\n      }\n      .light {\n        color: #000000;\n      }\n      .dark {\n        color: #ffffff;\n      }\n      .leaflet-tile-pane {\n        filter: var(--map-filter);\n      }\n      .dark .leaflet-bar a {\n        background-color: var(--card-background-color, #1c1c1c);\n        color: #ffffff;\n      }\n      .leaflet-marker-draggable {\n        cursor: move !important;\n      }\n      .leaflet-edit-resize {\n        border-radius: 50%;\n        cursor: nesw-resize !important;\n      }\n      .named-icon {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        flex-direction: column;\n        text-align: center;\n        color: var(--primary-text-color);\n      }\n      .leaflet-pane {\n        z-index: 0 !important;\n      }\n      .leaflet-control,\n      .leaflet-top,\n      .leaflet-bottom {\n        z-index: 1 !important;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-map\": HaMap;\n  }\n}\n","import {\n  Circle,\n  DivIcon,\n  DragEndEvent,\n  LatLng,\n  Marker,\n  MarkerOptions,\n} from \"leaflet\";\nimport {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { customElement, property, query, state } from \"lit/decorators\";\nimport memoizeOne from \"memoize-one\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\nimport type { LeafletModuleType } from \"../../common/dom/setup-leaflet-map\";\nimport type { HomeAssistant } from \"../../types\";\nimport \"../ha-input-helper-text\";\nimport \"./ha-map\";\nimport type { HaMap } from \"./ha-map\";\n\ndeclare global {\n  // for fire event\n  interface HASSDomEvents {\n    \"location-updated\": { id: string; location: [number, number] };\n    \"markers-updated\": undefined;\n    \"radius-updated\": { id: string; radius: number };\n    \"marker-clicked\": { id: string };\n  }\n}\n\nexport interface MarkerLocation {\n  latitude: number;\n  longitude: number;\n  radius?: number;\n  name?: string;\n  id: string;\n  icon?: string;\n  radius_color?: string;\n  location_editable?: boolean;\n  radius_editable?: boolean;\n}\n\n@customElement(\"ha-locations-editor\")\nexport class HaLocationsEditor extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public locations?: MarkerLocation[];\n\n  @property() public helper?: string;\n\n  @property({ type: Boolean }) public autoFit = false;\n\n  @property({ type: Number }) public zoom = 16;\n\n  @property({ type: Boolean }) public darkMode?: boolean;\n\n  @state() private _locationMarkers?: Record<string, Marker | Circle>;\n\n  @state() private _circles: Record<string, Circle> = {};\n\n  @query(\"ha-map\", true) private map!: HaMap;\n\n  private Leaflet?: LeafletModuleType;\n\n  constructor() {\n    super();\n\n    import(\"leaflet\").then((module) => {\n      import(\"leaflet-draw\").then(() => {\n        this.Leaflet = module.default as LeafletModuleType;\n        this._updateMarkers();\n        this.updateComplete.then(() => this.fitMap());\n      });\n    });\n  }\n\n  public fitMap(): void {\n    this.map.fitMap();\n  }\n\n  public fitMarker(id: string): void {\n    if (!this.map.leafletMap || !this._locationMarkers) {\n      return;\n    }\n    const marker = this._locationMarkers[id];\n    if (!marker) {\n      return;\n    }\n    if (\"getBounds\" in marker) {\n      this.map.leafletMap.fitBounds(marker.getBounds());\n      (marker as Circle).bringToFront();\n    } else {\n      const circle = this._circles[id];\n      if (circle) {\n        this.map.leafletMap.fitBounds(circle.getBounds());\n      } else {\n        this.map.leafletMap.setView(marker.getLatLng(), this.zoom);\n      }\n    }\n  }\n\n  protected render(): TemplateResult {\n    return html`\n      <ha-map\n        .hass=${this.hass}\n        .layers=${this._getLayers(this._circles, this._locationMarkers)}\n        .zoom=${this.zoom}\n        .autoFit=${this.autoFit}\n        .darkMode=${this.darkMode}\n      ></ha-map>\n      ${this.helper\n        ? html`<ha-input-helper-text>${this.helper}</ha-input-helper-text>`\n        : \"\"}\n    `;\n  }\n\n  private _getLayers = memoizeOne(\n    (\n      circles: Record<string, Circle>,\n      markers?: Record<string, Marker | Circle>\n    ): Array<Marker | Circle> => {\n      const layers: Array<Marker | Circle> = [];\n      Array.prototype.push.apply(layers, Object.values(circles));\n      if (markers) {\n        Array.prototype.push.apply(layers, Object.values(markers));\n      }\n      return layers;\n    }\n  );\n\n  public willUpdate(changedProps: PropertyValues): void {\n    super.willUpdate(changedProps);\n\n    // Still loading.\n    if (!this.Leaflet) {\n      return;\n    }\n\n    if (changedProps.has(\"locations\")) {\n      this._updateMarkers();\n    }\n  }\n\n  private _updateLocation(ev: DragEndEvent) {\n    const marker = ev.target;\n    const latlng: LatLng = marker.getLatLng();\n    let longitude: number = latlng.lng;\n    if (Math.abs(longitude) > 180.0) {\n      // Normalize longitude if map provides values beyond -180 to +180 degrees.\n      longitude = (((longitude % 360.0) + 540.0) % 360.0) - 180.0;\n    }\n    const location: [number, number] = [latlng.lat, longitude];\n    fireEvent(\n      this,\n      \"location-updated\",\n      { id: marker.id, location },\n      { bubbles: false }\n    );\n  }\n\n  private _updateRadius(ev: DragEndEvent) {\n    const marker = ev.target;\n    const circle = this._locationMarkers![marker.id] as Circle;\n    fireEvent(\n      this,\n      \"radius-updated\",\n      { id: marker.id, radius: circle.getRadius() },\n      { bubbles: false }\n    );\n  }\n\n  private _markerClicked(ev: DragEndEvent) {\n    const marker = ev.target;\n    fireEvent(this, \"marker-clicked\", { id: marker.id }, { bubbles: false });\n  }\n\n  private _updateMarkers(): void {\n    if (!this.locations || !this.locations.length) {\n      this._circles = {};\n      this._locationMarkers = undefined;\n      return;\n    }\n\n    const locationMarkers = {};\n    const circles = {};\n\n    const defaultZoneRadiusColor =\n      getComputedStyle(this).getPropertyValue(\"--accent-color\");\n\n    this.locations.forEach((location: MarkerLocation) => {\n      let icon: DivIcon | undefined;\n      if (location.icon) {\n        // create icon\n        const el = document.createElement(\"div\");\n        el.className = \"named-icon\";\n        if (location.name) {\n          el.innerText = location.name;\n        }\n        const iconEl = document.createElement(\"ha-icon\");\n        iconEl.setAttribute(\"icon\", location.icon);\n        el.prepend(iconEl);\n\n        icon = this.Leaflet!.divIcon({\n          html: el.outerHTML,\n          iconSize: [24, 24],\n          className: \"light\",\n        });\n      }\n      if (location.radius) {\n        const circle = this.Leaflet!.circle(\n          [location.latitude, location.longitude],\n          {\n            color: location.radius_color || defaultZoneRadiusColor,\n            radius: location.radius,\n          }\n        );\n        if (location.radius_editable || location.location_editable) {\n          // @ts-ignore\n          circle.editing.enable();\n          circle.addEventListener(\"add\", () => {\n            // @ts-ignore\n            const moveMarker = circle.editing._moveMarker;\n            // @ts-ignore\n            const resizeMarker = circle.editing._resizeMarkers[0];\n            if (icon) {\n              moveMarker.setIcon(icon);\n            }\n            resizeMarker.id = moveMarker.id = location.id;\n            moveMarker\n              .addEventListener(\n                \"dragend\",\n                // @ts-ignore\n                (ev: DragEndEvent) => this._updateLocation(ev)\n              )\n              .addEventListener(\n                \"click\",\n                // @ts-ignore\n                (ev: MouseEvent) => this._markerClicked(ev)\n              );\n            if (location.radius_editable) {\n              resizeMarker.addEventListener(\n                \"dragend\",\n                // @ts-ignore\n                (ev: DragEndEvent) => this._updateRadius(ev)\n              );\n            } else {\n              resizeMarker.remove();\n            }\n          });\n          locationMarkers[location.id] = circle;\n        } else {\n          circles[location.id] = circle;\n        }\n      }\n      if (\n        !location.radius ||\n        (!location.radius_editable && !location.location_editable)\n      ) {\n        const options: MarkerOptions = {\n          title: location.name,\n          draggable: location.location_editable,\n        };\n\n        if (icon) {\n          options.icon = icon;\n        }\n\n        const marker = this.Leaflet!.marker(\n          [location.latitude, location.longitude],\n          options\n        )\n          .addEventListener(\"dragend\", (ev: DragEndEvent) =>\n            this._updateLocation(ev)\n          )\n          .addEventListener(\n            // @ts-ignore\n            \"click\",\n            // @ts-ignore\n            (ev: MouseEvent) => this._markerClicked(ev)\n          );\n        (marker as any).id = location.id;\n\n        locationMarkers[location.id] = marker;\n      }\n    });\n    this._circles = circles;\n    this._locationMarkers = locationMarkers;\n    fireEvent(this, \"markers-updated\");\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      ha-map {\n        display: block;\n        height: 100%;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-locations-editor\": HaLocationsEditor;\n  }\n}\n","import { css, html, LitElement } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport memoizeOne from \"memoize-one\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\nimport type {\n  LocationSelector,\n  LocationSelectorValue,\n} from \"../../data/selector\";\nimport type { HomeAssistant } from \"../../types\";\nimport type { MarkerLocation } from \"../map/ha-locations-editor\";\nimport \"../map/ha-locations-editor\";\n\n@customElement(\"ha-selector-location\")\nexport class HaLocationSelector extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public selector!: LocationSelector;\n\n  @property() public value?: LocationSelectorValue;\n\n  @property() public label?: string;\n\n  @property() public helper?: string;\n\n  @property({ type: Boolean, reflect: true }) public disabled = false;\n\n  protected render() {\n    return html`\n      <ha-locations-editor\n        class=\"flex\"\n        .hass=${this.hass}\n        .helper=${this.helper}\n        .locations=${this._location(this.selector, this.value)}\n        @location-updated=${this._locationChanged}\n        @radius-updated=${this._radiusChanged}\n      ></ha-locations-editor>\n    `;\n  }\n\n  private _location = memoizeOne(\n    (\n      selector: LocationSelector,\n      value?: LocationSelectorValue\n    ): MarkerLocation[] => {\n      const computedStyles = getComputedStyle(this);\n      const zoneRadiusColor = selector.location.radius\n        ? computedStyles.getPropertyValue(\"--zone-radius-color\") ||\n          computedStyles.getPropertyValue(\"--accent-color\")\n        : undefined;\n      return [\n        {\n          id: \"location\",\n          latitude: value?.latitude || this.hass.config.latitude,\n          longitude: value?.longitude || this.hass.config.longitude,\n          radius: selector.location.radius ? value?.radius || 1000 : undefined,\n          radius_color: zoneRadiusColor,\n          icon:\n            selector.location.icon || selector.location.radius\n              ? \"mdi:map-marker-radius\"\n              : \"mdi:map-marker\",\n          location_editable: true,\n          radius_editable: true,\n        },\n      ];\n    }\n  );\n\n  private _locationChanged(ev: CustomEvent) {\n    const [latitude, longitude] = ev.detail.location;\n    fireEvent(this, \"value-changed\", {\n      value: { ...this.value, latitude, longitude },\n    });\n  }\n\n  private _radiusChanged(ev: CustomEvent) {\n    const radius = ev.detail.radius;\n    fireEvent(this, \"value-changed\", { value: { ...this.value, radius } });\n  }\n\n  static styles = css`\n    :host {\n      display: block;\n      height: 400px;\n    }\n  `;\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-selector-location\": HaLocationSelector;\n  }\n}\n"],"names":[],"sourceRoot":""}