{"version":3,"file":"1b19d9f8.js","mappings":";;;AAqEA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;;;AAGA;AACA;;;AAnBA;;ACjCA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AA9BA;ACqEA;AAEA","sources":["webpack://home-assistant-frontend/./src/components/entity/ha-entity-attribute-picker.ts","webpack://home-assistant-frontend/./src/components/ha-selector/ha-selector-attribute.ts","webpack://home-assistant-frontend/./src/data/entity_attributes.ts"],"sourcesContent":["import { HassEntity } from \"home-assistant-js-websocket\";\nimport { html, LitElement, PropertyValues, TemplateResult } from \"lit\";\nimport { customElement, property, query } from \"lit/decorators\";\nimport { formatAttributeName } from \"../../data/entity_attributes\";\nimport { PolymerChangedEvent } from \"../../polymer-types\";\nimport { HomeAssistant } from \"../../types\";\nimport \"../ha-combo-box\";\nimport type { HaComboBox } from \"../ha-combo-box\";\n\nexport type HaEntityPickerEntityFilterFunc = (entityId: HassEntity) => boolean;\n\n@customElement(\"ha-entity-attribute-picker\")\nclass HaEntityAttributePicker extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property() public entityId?: string;\n\n  /**\n   * List of attributes to be hidden.\n   * @type {Array}\n   * @attr hide-attributes\n   */\n  @property({ type: Array, attribute: \"hide-attributes\" })\n  public hideAttributes?: string[];\n\n  @property({ type: Boolean }) public autofocus = false;\n\n  @property({ type: Boolean }) public disabled = false;\n\n  @property({ type: Boolean }) public required = false;\n\n  @property({ type: Boolean, attribute: \"allow-custom-value\" })\n  public allowCustomValue;\n\n  @property() public label?: string;\n\n  @property() public value?: string;\n\n  @property() public helper?: string;\n\n  @property({ type: Boolean }) private _opened = false;\n\n  @query(\"ha-combo-box\", true) private _comboBox!: HaComboBox;\n\n  protected shouldUpdate(changedProps: PropertyValues) {\n    return !(!changedProps.has(\"_opened\") && this._opened);\n  }\n\n  protected updated(changedProps: PropertyValues) {\n    if (changedProps.has(\"_opened\") && this._opened) {\n      const state = this.entityId ? this.hass.states[this.entityId] : undefined;\n      (this._comboBox as any).items = state\n        ? Object.keys(state.attributes)\n            .filter((key) => !this.hideAttributes?.includes(key))\n            .map((key) => ({\n              value: key,\n              label: formatAttributeName(key),\n            }))\n        : [];\n    }\n  }\n\n  protected render(): TemplateResult {\n    if (!this.hass) {\n      return html``;\n    }\n\n    return html`\n      <ha-combo-box\n        .hass=${this.hass}\n        .value=${this.value ? formatAttributeName(this.value) : \"\"}\n        .autofocus=${this.autofocus}\n        .label=${this.label ??\n        this.hass.localize(\n          \"ui.components.entity.entity-attribute-picker.attribute\"\n        )}\n        .disabled=${this.disabled || !this.entityId}\n        .required=${this.required}\n        .helper=${this.helper}\n        .allowCustomValue=${this.allowCustomValue}\n        item-value-path=\"value\"\n        item-label-path=\"label\"\n        @opened-changed=${this._openedChanged}\n        @value-changed=${this._valueChanged}\n      >\n      </ha-combo-box>\n    `;\n  }\n\n  private _openedChanged(ev: PolymerChangedEvent<boolean>) {\n    this._opened = ev.detail.value;\n  }\n\n  private _valueChanged(ev: PolymerChangedEvent<string>) {\n    this.value = ev.detail.value;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-entity-attribute-picker\": HaEntityAttributePicker;\n  }\n}\n","import { html, LitElement, PropertyValues } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\nimport { AttributeSelector } from \"../../data/selector\";\nimport { SubscribeMixin } from \"../../mixins/subscribe-mixin\";\nimport { HomeAssistant } from \"../../types\";\nimport \"../entity/ha-entity-attribute-picker\";\n\n@customElement(\"ha-selector-attribute\")\nexport class HaSelectorAttribute extends SubscribeMixin(LitElement) {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public selector!: AttributeSelector;\n\n  @property() public value?: any;\n\n  @property() public label?: string;\n\n  @property() public helper?: string;\n\n  @property({ type: Boolean }) public disabled = false;\n\n  @property({ type: Boolean }) public required = true;\n\n  @property({ attribute: false }) public context?: {\n    filter_entity?: string;\n  };\n\n  protected render() {\n    return html`\n      <ha-entity-attribute-picker\n        .hass=${this.hass}\n        .entityId=${this.selector.attribute.entity_id ||\n        this.context?.filter_entity}\n        .hideAttributes=${this.selector.attribute.hide_attributes}\n        .value=${this.value}\n        .label=${this.label}\n        .helper=${this.helper}\n        .disabled=${this.disabled}\n        .required=${this.required}\n        allow-custom-value\n      ></ha-entity-attribute-picker>\n    `;\n  }\n\n  protected updated(changedProps: PropertyValues): void {\n    super.updated(changedProps);\n    if (\n      // No need to filter value if no value\n      !this.value ||\n      // Only adjust value if we used the context\n      this.selector.attribute.entity_id ||\n      // Only check if context has changed\n      !changedProps.has(\"context\")\n    ) {\n      return;\n    }\n\n    const oldContext = changedProps.get(\"context\") as this[\"context\"];\n\n    if (\n      !this.context ||\n      oldContext?.filter_entity === this.context.filter_entity\n    ) {\n      return;\n    }\n\n    // Validate that that the attribute is still valid for this entity, else unselect.\n    let invalid = false;\n    if (this.context.filter_entity) {\n      const stateObj = this.hass.states[this.context.filter_entity];\n\n      if (!(stateObj && this.value in stateObj.attributes)) {\n        invalid = true;\n      }\n    } else {\n      invalid = this.value !== undefined;\n    }\n\n    if (invalid) {\n      fireEvent(this, \"value-changed\", {\n        value: undefined,\n      });\n    }\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-selector-attribute\": HaSelectorAttribute;\n  }\n}\n","import { html, TemplateResult } from \"lit\";\nimport { until } from \"lit/directives/until\";\nimport checkValidDate from \"../common/datetime/check_valid_date\";\nimport { formatDate } from \"../common/datetime/format_date\";\nimport { formatDateTimeWithSeconds } from \"../common/datetime/format_date_time\";\nimport { formatNumber } from \"../common/number/format_number\";\nimport { capitalizeFirstLetter } from \"../common/string/capitalize-first-letter\";\nimport { isDate } from \"../common/string/is_date\";\nimport { isTimestamp } from \"../common/string/is_timestamp\";\nimport { HomeAssistant } from \"../types\";\n\nlet jsYamlPromise: Promise<typeof import(\"../resources/js-yaml-dump\")>;\n\nexport const STATE_ATTRIBUTES = [\n  \"assumed_state\",\n  \"attribution\",\n  \"custom_ui_more_info\",\n  \"custom_ui_state_card\",\n  \"device_class\",\n  \"editable\",\n  \"emulated_hue_name\",\n  \"emulated_hue\",\n  \"entity_picture\",\n  \"friendly_name\",\n  \"haaska_hidden\",\n  \"haaska_name\",\n  \"icon\",\n  \"initial_state\",\n  \"last_reset\",\n  \"restored\",\n  \"state_class\",\n  \"supported_features\",\n  \"unit_of_measurement\",\n];\n\n// Convert from internal snake_case format to user-friendly format\nexport function formatAttributeName(value: string): string {\n  value = value\n    .replace(/_/g, \" \")\n    .replace(/\\bid\\b/g, \"ID\")\n    .replace(/\\bip\\b/g, \"IP\")\n    .replace(/\\bmac\\b/g, \"MAC\")\n    .replace(/\\bgps\\b/g, \"GPS\");\n  return capitalizeFirstLetter(value);\n}\n\nexport function formatAttributeValue(\n  hass: HomeAssistant,\n  value: any\n): string | TemplateResult {\n  if (value === null) {\n    return \"â€”\";\n  }\n\n  // YAML handling\n  if (\n    (Array.isArray(value) && value.some((val) => val instanceof Object)) ||\n    (!Array.isArray(value) && value instanceof Object)\n  ) {\n    if (!jsYamlPromise) {\n      jsYamlPromise = import(\"../resources/js-yaml-dump\");\n    }\n    const yaml = jsYamlPromise.then((jsYaml) => jsYaml.dump(value));\n    return html`<pre>${until(yaml, \"\")}</pre>`;\n  }\n\n  if (typeof value === \"number\") {\n    return formatNumber(value, hass.locale);\n  }\n\n  if (typeof value === \"string\") {\n    // URL handling\n    if (value.startsWith(\"http\")) {\n      try {\n        // If invalid URL, exception will be raised\n        const url = new URL(value);\n        if (url.protocol === \"http:\" || url.protocol === \"https:\")\n          return html`<a target=\"_blank\" rel=\"noreferrer\" href=${value}\n            >${value}</a\n          >`;\n      } catch (_) {\n        // Nothing to do here\n      }\n    }\n\n    // Date handling\n    if (isDate(value, true)) {\n      // Timestamp handling\n      if (isTimestamp(value)) {\n        const date = new Date(value);\n        if (checkValidDate(date)) {\n          return formatDateTimeWithSeconds(date, hass.locale);\n        }\n      }\n\n      // Value was not a timestamp, so only do date formatting\n      const date = new Date(value);\n      if (checkValidDate(date)) {\n        return formatDate(date, hass.locale);\n      }\n    }\n  }\n\n  return Array.isArray(value) ? value.join(\", \") : value;\n}\n"],"names":[],"sourceRoot":""}