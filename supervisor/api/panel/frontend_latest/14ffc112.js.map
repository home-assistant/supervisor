{"version":3,"file":"14ffc112.js","mappings":";AAwCA;;AAEA;AACA;;;AAiOA;AACA;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAGA","sources":["webpack://home-assistant-frontend/./src/components/device/ha-device-picker.ts"],"sourcesContent":["import \"@material/mwc-list/mwc-list-item\";\nimport { UnsubscribeFunc } from \"home-assistant-js-websocket\";\nimport { html, LitElement, PropertyValues, TemplateResult } from \"lit\";\nimport { ComboBoxLitRenderer } from \"@vaadin/combo-box/lit\";\nimport { customElement, property, query, state } from \"lit/decorators\";\nimport memoizeOne from \"memoize-one\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\nimport { computeDomain } from \"../../common/entity/compute_domain\";\nimport { stringCompare } from \"../../common/string/compare\";\nimport {\n  AreaRegistryEntry,\n  subscribeAreaRegistry,\n} from \"../../data/area_registry\";\nimport {\n  computeDeviceName,\n  DeviceEntityLookup,\n  DeviceRegistryEntry,\n  subscribeDeviceRegistry,\n} from \"../../data/device_registry\";\nimport {\n  EntityRegistryEntry,\n  subscribeEntityRegistry,\n} from \"../../data/entity_registry\";\nimport { SubscribeMixin } from \"../../mixins/subscribe-mixin\";\nimport { PolymerChangedEvent } from \"../../polymer-types\";\nimport { HomeAssistant } from \"../../types\";\nimport \"../ha-combo-box\";\nimport type { HaComboBox } from \"../ha-combo-box\";\n\ninterface Device {\n  name: string;\n  area: string;\n  id: string;\n}\n\nexport type HaDevicePickerDeviceFilterFunc = (\n  device: DeviceRegistryEntry\n) => boolean;\n\nconst rowRenderer: ComboBoxLitRenderer<Device> = (item) => html`<mwc-list-item\n  .twoline=${!!item.area}\n>\n  <span>${item.name}</span>\n  <span slot=\"secondary\">${item.area}</span>\n</mwc-list-item>`;\n\n@customElement(\"ha-device-picker\")\nexport class HaDevicePicker extends SubscribeMixin(LitElement) {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property() public label?: string;\n\n  @property() public value?: string;\n\n  @property() public helper?: string;\n\n  @property() public devices?: DeviceRegistryEntry[];\n\n  @property() public areas?: AreaRegistryEntry[];\n\n  @property() public entities?: EntityRegistryEntry[];\n\n  /**\n   * Show only devices with entities from specific domains.\n   * @type {Array}\n   * @attr include-domains\n   */\n  @property({ type: Array, attribute: \"include-domains\" })\n  public includeDomains?: string[];\n\n  /**\n   * Show no devices with entities of these domains.\n   * @type {Array}\n   * @attr exclude-domains\n   */\n  @property({ type: Array, attribute: \"exclude-domains\" })\n  public excludeDomains?: string[];\n\n  /**\n   * Show only devices with entities of these device classes.\n   * @type {Array}\n   * @attr include-device-classes\n   */\n  @property({ type: Array, attribute: \"include-device-classes\" })\n  public includeDeviceClasses?: string[];\n\n  @property() public deviceFilter?: HaDevicePickerDeviceFilterFunc;\n\n  @property({ type: Boolean }) public disabled?: boolean;\n\n  @property({ type: Boolean }) public required?: boolean;\n\n  @state() private _opened?: boolean;\n\n  @query(\"ha-combo-box\", true) public comboBox!: HaComboBox;\n\n  private _init = false;\n\n  private _getDevices = memoizeOne(\n    (\n      devices: DeviceRegistryEntry[],\n      areas: AreaRegistryEntry[],\n      entities: EntityRegistryEntry[],\n      includeDomains: this[\"includeDomains\"],\n      excludeDomains: this[\"excludeDomains\"],\n      includeDeviceClasses: this[\"includeDeviceClasses\"],\n      deviceFilter: this[\"deviceFilter\"]\n    ): Device[] => {\n      if (!devices.length) {\n        return [\n          {\n            id: \"no_devices\",\n            area: \"\",\n            name: this.hass.localize(\"ui.components.device-picker.no_devices\"),\n          },\n        ];\n      }\n\n      const deviceEntityLookup: DeviceEntityLookup = {};\n\n      if (includeDomains || excludeDomains || includeDeviceClasses) {\n        for (const entity of entities) {\n          if (!entity.device_id) {\n            continue;\n          }\n          if (!(entity.device_id in deviceEntityLookup)) {\n            deviceEntityLookup[entity.device_id] = [];\n          }\n          deviceEntityLookup[entity.device_id].push(entity);\n        }\n      }\n\n      const areaLookup: { [areaId: string]: AreaRegistryEntry } = {};\n      for (const area of areas) {\n        areaLookup[area.area_id] = area;\n      }\n\n      let inputDevices = devices.filter(\n        (device) => device.id === this.value || !device.disabled_by\n      );\n\n      if (includeDomains) {\n        inputDevices = inputDevices.filter((device) => {\n          const devEntities = deviceEntityLookup[device.id];\n          if (!devEntities || !devEntities.length) {\n            return false;\n          }\n          return deviceEntityLookup[device.id].some((entity) =>\n            includeDomains.includes(computeDomain(entity.entity_id))\n          );\n        });\n      }\n\n      if (excludeDomains) {\n        inputDevices = inputDevices.filter((device) => {\n          const devEntities = deviceEntityLookup[device.id];\n          if (!devEntities || !devEntities.length) {\n            return true;\n          }\n          return entities.every(\n            (entity) =>\n              !excludeDomains.includes(computeDomain(entity.entity_id))\n          );\n        });\n      }\n\n      if (includeDeviceClasses) {\n        inputDevices = inputDevices.filter((device) => {\n          const devEntities = deviceEntityLookup[device.id];\n          if (!devEntities || !devEntities.length) {\n            return false;\n          }\n          return deviceEntityLookup[device.id].some((entity) => {\n            const stateObj = this.hass.states[entity.entity_id];\n            if (!stateObj) {\n              return false;\n            }\n            return (\n              stateObj.attributes.device_class &&\n              includeDeviceClasses.includes(stateObj.attributes.device_class)\n            );\n          });\n        });\n      }\n\n      if (deviceFilter) {\n        inputDevices = inputDevices.filter(\n          (device) =>\n            // We always want to include the device of the current value\n            device.id === this.value || deviceFilter!(device)\n        );\n      }\n\n      const outputDevices = inputDevices.map((device) => ({\n        id: device.id,\n        name: computeDeviceName(\n          device,\n          this.hass,\n          deviceEntityLookup[device.id]\n        ),\n        area:\n          device.area_id && areaLookup[device.area_id]\n            ? areaLookup[device.area_id].name\n            : this.hass.localize(\"ui.components.device-picker.no_area\"),\n      }));\n      if (!outputDevices.length) {\n        return [\n          {\n            id: \"no_devices\",\n            area: \"\",\n            name: this.hass.localize(\"ui.components.device-picker.no_match\"),\n          },\n        ];\n      }\n      if (outputDevices.length === 1) {\n        return outputDevices;\n      }\n      return outputDevices.sort((a, b) =>\n        stringCompare(a.name || \"\", b.name || \"\")\n      );\n    }\n  );\n\n  public async open() {\n    await this.updateComplete;\n    await this.comboBox?.open();\n  }\n\n  public async focus() {\n    await this.updateComplete;\n    await this.comboBox?.focus();\n  }\n\n  public hassSubscribe(): UnsubscribeFunc[] {\n    return [\n      subscribeDeviceRegistry(this.hass.connection!, (devices) => {\n        this.devices = devices;\n      }),\n      subscribeAreaRegistry(this.hass.connection!, (areas) => {\n        this.areas = areas;\n      }),\n      subscribeEntityRegistry(this.hass.connection!, (entities) => {\n        this.entities = entities;\n      }),\n    ];\n  }\n\n  protected updated(changedProps: PropertyValues) {\n    if (\n      (!this._init && this.devices && this.areas && this.entities) ||\n      (this._init && changedProps.has(\"_opened\") && this._opened)\n    ) {\n      this._init = true;\n      (this.comboBox as any).items = this._getDevices(\n        this.devices!,\n        this.areas!,\n        this.entities!,\n        this.includeDomains,\n        this.excludeDomains,\n        this.includeDeviceClasses,\n        this.deviceFilter\n      );\n    }\n  }\n\n  protected render(): TemplateResult {\n    return html`\n      <ha-combo-box\n        .hass=${this.hass}\n        .label=${this.label === undefined && this.hass\n          ? this.hass.localize(\"ui.components.device-picker.device\")\n          : this.label}\n        .value=${this._value}\n        .helper=${this.helper}\n        .renderer=${rowRenderer}\n        .disabled=${this.disabled}\n        .required=${this.required}\n        item-value-path=\"id\"\n        item-label-path=\"name\"\n        @opened-changed=${this._openedChanged}\n        @value-changed=${this._deviceChanged}\n      ></ha-combo-box>\n    `;\n  }\n\n  private get _value() {\n    return this.value || \"\";\n  }\n\n  private _deviceChanged(ev: PolymerChangedEvent<string>) {\n    ev.stopPropagation();\n    let newValue = ev.detail.value;\n\n    if (newValue === \"no_devices\") {\n      newValue = \"\";\n    }\n\n    if (newValue !== this._value) {\n      this._setValue(newValue);\n    }\n  }\n\n  private _openedChanged(ev: PolymerChangedEvent<boolean>) {\n    this._opened = ev.detail.value;\n  }\n\n  private _setValue(value: string) {\n    this.value = value;\n    setTimeout(() => {\n      fireEvent(this, \"value-changed\", { value });\n      fireEvent(this, \"change\");\n    }, 0);\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-device-picker\": HaDevicePicker;\n  }\n}\n"],"names":[],"sourceRoot":""}